"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.patchLogger = patchLogger;
exports.getLogger = getLogger;
exports.default = exports.log = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _npmlog = _interopRequireDefault(require("npmlog"));

var _lodash = _interopRequireDefault(require("lodash"));

const NPM_LEVELS = ['silly', 'verbose', 'debug', 'info', 'http', 'warn', 'error'];
const MAX_LOG_RECORDS_COUNT = 3000;
let mockLog = {};

for (var _i = 0; _i < NPM_LEVELS.length; _i++) {
  let level = NPM_LEVELS[_i];

  mockLog[level] = () => {};
}

function patchLogger(logger) {
  if (!logger.debug) {
    logger.addLevel('debug', 1000, {
      fg: 'blue',
      bg: 'black'
    }, 'dbug');
  }
}

function _getLogger() {
  const testingMode = parseInt(process.env._TESTING, 10) === 1;
  const forceLogMode = parseInt(process.env._FORCE_LOGS, 10) === 1;
  const usingGlobalLog = !!global._global_npmlog;
  let logger;

  if (testingMode && !forceLogMode) {
    logger = mockLog;
  } else {
    logger = global._global_npmlog || _npmlog.default;
    logger.maxRecordSize = MAX_LOG_RECORDS_COUNT;
  }

  patchLogger(logger);
  return [logger, usingGlobalLog];
}

function getLogger(prefix = null) {
  let _getLogger2 = _getLogger(),
      _getLogger3 = (0, _slicedToArray2.default)(_getLogger2, 2),
      logger = _getLogger3[0],
      usingGlobalLog = _getLogger3[1];

  let wrappedLogger = {
    unwrap: () => logger
  };
  Object.defineProperty(wrappedLogger, 'level', {
    get: () => {
      return logger.level;
    },
    set: newValue => {
      logger.level = newValue;
    },
    enumerable: true,
    configurable: true
  });

  const unleakIfString = x => _lodash.default.isString(x) ? ` ${x}`.substr(1) : x;

  for (var _i2 = 0; _i2 < NPM_LEVELS.length; _i2++) {
    const level = NPM_LEVELS[_i2];

    wrappedLogger[level] = function (...args) {
      const actualPrefix = _lodash.default.isFunction(prefix) ? prefix() : prefix;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = args.map(unleakIfString)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          const arg = _step.value;
          let out = arg + '';

          if (_lodash.default.isError(arg) && arg.stack) {
            out = arg.stack;
          }

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = out.split('\n')[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              const line = _step2.value;
              logger[level](actualPrefix, line);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    };
  }

  wrappedLogger.errorAndThrow = function (err) {
    if (!(err instanceof Error)) {
      err = new Error(err);
    }

    this.error(unleakIfString(err));
    throw err;
  };

  if (!usingGlobalLog) {
    wrappedLogger.level = 'verbose';
  }

  wrappedLogger.levels = NPM_LEVELS;
  return wrappedLogger;
}

const log = getLogger();
exports.log = log;
var _default = log;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9sb2dnaW5nLmpzIl0sIm5hbWVzIjpbIk5QTV9MRVZFTFMiLCJNQVhfTE9HX1JFQ09SRFNfQ09VTlQiLCJtb2NrTG9nIiwibGV2ZWwiLCJwYXRjaExvZ2dlciIsImxvZ2dlciIsImRlYnVnIiwiYWRkTGV2ZWwiLCJmZyIsImJnIiwiX2dldExvZ2dlciIsInRlc3RpbmdNb2RlIiwicGFyc2VJbnQiLCJwcm9jZXNzIiwiZW52IiwiX1RFU1RJTkciLCJmb3JjZUxvZ01vZGUiLCJfRk9SQ0VfTE9HUyIsInVzaW5nR2xvYmFsTG9nIiwiZ2xvYmFsIiwiX2dsb2JhbF9ucG1sb2ciLCJucG1sb2ciLCJtYXhSZWNvcmRTaXplIiwiZ2V0TG9nZ2VyIiwicHJlZml4Iiwid3JhcHBlZExvZ2dlciIsInVud3JhcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic2V0IiwibmV3VmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwidW5sZWFrSWZTdHJpbmciLCJ4IiwiXyIsImlzU3RyaW5nIiwic3Vic3RyIiwiYXJncyIsImFjdHVhbFByZWZpeCIsImlzRnVuY3Rpb24iLCJtYXAiLCJhcmciLCJvdXQiLCJpc0Vycm9yIiwic3RhY2siLCJzcGxpdCIsImxpbmUiLCJlcnJvckFuZFRocm93IiwiZXJyIiwiRXJyb3IiLCJlcnJvciIsImxldmVscyIsImxvZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUlBLE1BQU1BLFVBQVUsR0FBRyxDQUFDLE9BQUQsRUFBVSxTQUFWLEVBQXFCLE9BQXJCLEVBQThCLE1BQTlCLEVBQXNDLE1BQXRDLEVBQThDLE1BQTlDLEVBQXNELE9BQXRELENBQW5CO0FBQ0EsTUFBTUMscUJBQXFCLEdBQUcsSUFBOUI7QUFHQSxJQUFJQyxPQUFPLEdBQUcsRUFBZDs7QUFDQSxzQkFBa0JGLFVBQWxCLGVBQThCO0FBQXpCLE1BQUlHLEtBQUssR0FBSUgsVUFBSixJQUFUOztBQUNIRSxFQUFBQSxP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S0FBVjtBQUNEOztBQUp5QztBQUFBO0FBQUE7O0FBQUE7QUFLMUMsa0NBQW1CRixHQUFHLENBQUNHLEtBQUosQ0FBVSxJQUFWLENBQW5CLG1JQUFvQztBQUFBLG9CQUF6QkMsSUFBeUI7QUFDbEMzQyxjQUFBQSxNQUFNLENBQUNGLEtBQUQsQ0FBTixDQUFjcUMsWUFBZCxFQUE0QlEsSUFBNUI7QUFDRDtBQVB5QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUTNDO0FBVnVDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXekMsS0FYRDtBQVlEOztBQUVEdkIsRUFBQUEsYUFBYSxDQUFDd0IsYUFBZCxHQUE4QixVQUFVQyxHQUFWLEVBQWU7QUFFM0MsUUFBSSxFQUFFQSxHQUFHLFlBQVlDLEtBQWpCLENBQUosRUFBNkI7QUFDM0JELE1BQUFBLEdBQUcsR0FBRyxJQUFJQyxLQUFKLENBQVVELEdBQVYsQ0FBTjtBQUNEOztBQUVELFNBQUtFLEtBQUwsQ0FBV2xCLGNBQWMsQ0FBQ2dCLEdBQUQsQ0FBekI7QUFDQSxVQUFNQSxHQUFOO0FBQ0QsR0FSRDs7QUFTQSxNQUFJLENBQUNoQyxjQUFMLEVBQXFCO0FBSW5CTyxJQUFBQSxhQUFhLENBQUN0QixLQUFkLEdBQXNCLFNBQXRCO0FBQ0Q7O0FBQ0RzQixFQUFBQSxhQUFhLENBQUM0QixNQUFkLEdBQXVCckQsVUFBdkI7QUFDQSxTQUFPeUIsYUFBUDtBQUNEOztBQUdELE1BQU02QixHQUFHLEdBQUcvQixTQUFTLEVBQXJCOztlQUdlK0IsRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBucG1sb2cgZnJvbSAnbnBtbG9nJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cblxuLy8gbGV2ZWxzIHRoYXQgYXJlIGF2YWlsYWJsZSBmcm9tIGBucG1sb2dgXG5jb25zdCBOUE1fTEVWRUxTID0gWydzaWxseScsICd2ZXJib3NlJywgJ2RlYnVnJywgJ2luZm8nLCAnaHR0cCcsICd3YXJuJywgJ2Vycm9yJ107XG5jb25zdCBNQVhfTE9HX1JFQ09SRFNfQ09VTlQgPSAzMDAwO1xuXG4vLyBtb2NrIGxvZyBvYmplY3QgdXNlZCBpbiB0ZXN0aW5nIG1vZGVcbmxldCBtb2NrTG9nID0ge307XG5mb3IgKGxldCBsZXZlbCBvZiBOUE1fTEVWRUxTKSB7XG4gIG1vY2tMb2dbbGV2ZWxdID0gKCkgPT4ge307XG59XG5cbmZ1bmN0aW9uIHBhdGNoTG9nZ2VyIChsb2dnZXIpIHtcbiAgaWYgKCFsb2dnZXIuZGVidWcpIHtcbiAgICBsb2dnZXIuYWRkTGV2ZWwoJ2RlYnVnJywgMTAwMCwgeyBmZzogJ2JsdWUnLCBiZzogJ2JsYWNrJyB9LCAnZGJ1ZycpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRMb2dnZXIgKCkge1xuICAvLyBjaGVjayBpZiB0aGUgdXNlciBzZXQgdGhlIGBfVEVTVElOR2Agb3IgYF9GT1JDRV9MT0dTYCBmbGFnXG4gIGNvbnN0IHRlc3RpbmdNb2RlID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuX1RFU1RJTkcsIDEwKSA9PT0gMTtcbiAgY29uc3QgZm9yY2VMb2dNb2RlID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuX0ZPUkNFX0xPR1MsIDEwKSA9PT0gMTtcblxuICAvLyBpZiBpcyBwb3NzaWJsZSB0aGF0IHRoZXJlIGlzIGEgbG9nZ2VyIGluc3RhbmNlIHRoYXQgaXMgYWxyZWFkeSBhcm91bmQsXG4gIC8vIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0IG8gdXNlIHRoYXRcbiAgY29uc3QgdXNpbmdHbG9iYWxMb2cgPSAhIWdsb2JhbC5fZ2xvYmFsX25wbWxvZztcbiAgbGV0IGxvZ2dlcjtcbiAgaWYgKHRlc3RpbmdNb2RlICYmICFmb3JjZUxvZ01vZGUpIHtcbiAgICAvLyBpbiB0ZXN0aW5nIG1vZGUsIHVzZSBhIG1vY2sgbG9nZ2VyIG9iamVjdCB0aGF0IHdlIGNhbiBxdWVyeVxuICAgIGxvZ2dlciA9IG1vY2tMb2c7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCBlaXRoZXIgdXNlIHRoZSBnbG9iYWwsIG9yIGEgbmV3IGBucG1sb2dgIG9iamVjdFxuICAgIGxvZ2dlciA9IGdsb2JhbC5fZ2xvYmFsX25wbWxvZyB8fCBucG1sb2c7XG4gICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMTAwMDAsIHdoaWNoIGNhdXNlcyBleGNlc3NpdmUgbWVtb3J5IHVzYWdlXG4gICAgbG9nZ2VyLm1heFJlY29yZFNpemUgPSBNQVhfTE9HX1JFQ09SRFNfQ09VTlQ7XG4gIH1cbiAgcGF0Y2hMb2dnZXIobG9nZ2VyKTtcbiAgcmV0dXJuIFtsb2dnZXIsIHVzaW5nR2xvYmFsTG9nXTtcbn1cblxuZnVuY3Rpb24gZ2V0TG9nZ2VyIChwcmVmaXggPSBudWxsKSB7XG4gIGxldCBbbG9nZ2VyLCB1c2luZ0dsb2JhbExvZ10gPSBfZ2V0TG9nZ2VyKCk7XG5cbiAgLy8gd3JhcCB0aGUgbG9nZ2VyIHNvIHRoYXQgd2UgY2FuIGNhdGNoIGFuZCBtb2RpZnkgYW55IGxvZ2dpbmdcbiAgbGV0IHdyYXBwZWRMb2dnZXIgPSB7dW53cmFwOiAoKSA9PiBsb2dnZXJ9O1xuXG4gIC8vIGFsbG93IGFjY2VzcyB0byB0aGUgbGV2ZWwgb2YgdGhlIHVuZGVybHlpbmcgbG9nZ2VyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVkTG9nZ2VyLCAnbGV2ZWwnLCB7XG4gICAgZ2V0OiAoKSA9PiB7IHJldHVybiBsb2dnZXIubGV2ZWw7IH0sXG4gICAgc2V0OiAobmV3VmFsdWUpID0+IHsgbG9nZ2VyLmxldmVsID0gbmV3VmFsdWU7IH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8vIFRoaXMgbGFtYmRhIGZ1bmN0aW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrYXJvdW5kIHVuZXhwZWN0ZWQgbWVtb3J5IGxlYWtzXG4gIC8vIGNhdXNlZCBieSBOb2RlSlMgYmVoYXZpb3IgZGVzY3JpYmVkIGluIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTI4NjlcbiAgY29uc3QgdW5sZWFrSWZTdHJpbmcgPSAoeCkgPT4gXy5pc1N0cmluZyh4KSA/IGAgJHt4fWAuc3Vic3RyKDEpIDogeDtcbiAgLy8gYWRkIGFsbCB0aGUgbGV2ZWxzIGZyb20gYG5wbWxvZ2AsIGFuZCBtYXAgdG8gdGhlIHVuZGVybHlpbmcgbG9nZ2VyXG4gIGZvciAoY29uc3QgbGV2ZWwgb2YgTlBNX0xFVkVMUykge1xuICAgIHdyYXBwZWRMb2dnZXJbbGV2ZWxdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGFjdHVhbFByZWZpeCA9IF8uaXNGdW5jdGlvbihwcmVmaXgpID8gcHJlZml4KCkgOiBwcmVmaXg7XG4gICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzLm1hcCh1bmxlYWtJZlN0cmluZykpIHtcbiAgICAgICAgbGV0IG91dCA9IGFyZyArICcnO1xuICAgICAgICBpZiAoXy5pc0Vycm9yKGFyZykgJiYgYXJnLnN0YWNrKSB7XG4gICAgICAgICAgb3V0ID0gYXJnLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBvdXQuc3BsaXQoJ1xcbicpKSB7XG4gICAgICAgICAgbG9nZ2VyW2xldmVsXShhY3R1YWxQcmVmaXgsIGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvLyBhZGQgbWV0aG9kIHRvIGxvZyBhbiBlcnJvciwgYW5kIHRocm93IGl0LCBmb3IgY29udmVuaWVuY2VcbiAgd3JhcHBlZExvZ2dlci5lcnJvckFuZFRocm93ID0gZnVuY3Rpb24gKGVycikge1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIGFuIGBFcnJvcmAgb2JqZWN0LiBXcmFwIGlmIG5lY2Vzc2FyeVxuICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKGVycik7XG4gICAgfVxuICAgIC8vIGxvZyBhbmQgdGhyb3dcbiAgICB0aGlzLmVycm9yKHVubGVha0lmU3RyaW5nKGVycikpO1xuICAgIHRocm93IGVycjtcbiAgfTtcbiAgaWYgKCF1c2luZ0dsb2JhbExvZykge1xuICAgIC8vIGlmIHdlJ3JlIG5vdCB1c2luZyBhIGdsb2JhbCBsb2cgc3BlY2lmaWVkIGZyb20gc29tZSB0b3AtbGV2ZWwgcGFja2FnZSxcbiAgICAvLyBzZXQgdGhlIGxvZyBsZXZlbCB0byBhIGRlZmF1bHQgb2YgdmVyYm9zZS4gT3RoZXJ3aXNlLCBsZXQgdGhlIHRvcC1sZXZlbFxuICAgIC8vIHBhY2thZ2Ugc2V0IHRoZSBsb2cgbGV2ZWxcbiAgICB3cmFwcGVkTG9nZ2VyLmxldmVsID0gJ3ZlcmJvc2UnO1xuICB9XG4gIHdyYXBwZWRMb2dnZXIubGV2ZWxzID0gTlBNX0xFVkVMUztcbiAgcmV0dXJuIHdyYXBwZWRMb2dnZXI7XG59XG5cbi8vIGV4cG9ydCBhIGRlZmF1bHQgbG9nZ2VyIHdpdGggbm8gcHJlZml4XG5jb25zdCBsb2cgPSBnZXRMb2dnZXIoKTtcblxuZXhwb3J0IHsgbG9nLCBwYXRjaExvZ2dlciwgZ2V0TG9nZ2VyIH07XG5leHBvcnQgZGVmYXVsdCBsb2c7XG4iXSwiZmlsZSI6ImxpYi9sb2dnaW5nLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
