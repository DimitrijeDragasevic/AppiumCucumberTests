"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uploadFile = uploadFile;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _fs = require("fs");

var _fs2 = _interopRequireDefault(require("./fs"));

var _url = _interopRequireDefault(require("url"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _util = require("./util");

var _logger = _interopRequireDefault(require("./logger"));

var _requestPromise = _interopRequireDefault(require("request-promise"));

var _jsftp = _interopRequireDefault(require("jsftp"));

function uploadFileToHttp(_x) {
  return _uploadFileToHttp.apply(this, arguments);
}

function _uploadFileToHttp() {
  _uploadFileToHttp = (0, _asyncToGenerator2.default)(function* (remoteUrl, uploadOptions = {}) {
    _logger.default.debug(`${remoteUrl.protocol} upload options: ${JSON.stringify(uploadOptions)}`);

    const response = yield (0, _requestPromise.default)(uploadOptions);
    const responseDebugMsg = `Response code: ${response.statusCode}. ` + `Response body: ${JSON.stringify(response.body)}`;

    _logger.default.debug(responseDebugMsg);

    if (response.statusCode >= 400) {
      throw new Error(`Cannot upload the recorded media to '${remoteUrl.href}'. ${responseDebugMsg}`);
    }
  });
  return _uploadFileToHttp.apply(this, arguments);
}

function uploadFileToFtp(_x2, _x3) {
  return _uploadFileToFtp.apply(this, arguments);
}

function _uploadFileToFtp() {
  _uploadFileToFtp = (0, _asyncToGenerator2.default)(function* (localFileStream, remoteUrl, uploadOptions = {}) {
    _logger.default.debug(`${remoteUrl.protocol} upload options: ${JSON.stringify(uploadOptions)}`);

    return yield new _bluebird.default((resolve, reject) => {
      new _jsftp.default(uploadOptions).put(localFileStream, remoteUrl.pathname, err => {
        if (err) {
          return reject(err);
        }

        resolve();
      });
    });
  });
  return _uploadFileToFtp.apply(this, arguments);
}

function uploadFile(_x4, _x5) {
  return _uploadFile.apply(this, arguments);
}

function _uploadFile() {
  _uploadFile = (0, _asyncToGenerator2.default)(function* (localPath, remotePath, uploadOptions = {}) {
    if (!(yield _fs2.default.exists(localPath))) {
      throw new Error(`'${localPath}' does not exists or is not accessible`);
    }

    const remoteUrl = _url.default.parse(remotePath);

    const _ref = yield _fs2.default.stat(localPath),
          size = _ref.size;

    _logger.default.info(`Uploading '${localPath}' of ${(0, _util.toReadableSizeString)(size)} size to '${remotePath}'...`);

    const timeStarted = process.hrtime();

    if (['http:', 'https:'].includes(remoteUrl.protocol)) {
      yield uploadFileToHttp(remoteUrl, uploadOptions);
    } else if (remoteUrl.protocol === 'ftp:') {
      yield uploadFileToFtp((0, _fs.createReadStream)(localPath), remoteUrl, uploadOptions);
    } else {
      throw new Error(`Cannot upload the file at '${localPath}' to '${remotePath}'. ` + `Unsupported remote protocol '${remoteUrl.protocol}'. ` + `Only http/https and ftp protocols are supported.`);
    }

    const timeElapsed = process.hrtime(timeStarted)[0];

    _logger.default.info(`Uploaded '${localPath}' of ${(0, _util.toReadableSizeString)(size)} size in ${timeElapsed} second${timeElapsed === 1 ? '' : 's'}`);
  });
  return _uploadFile.apply(this, arguments);
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9uZXQuanMiXSwibmFtZXMiOlsidXBsb2FkRmlsZVRvSHR0cCIsInJlbW90ZVVybCIsInVwbG9hZE9wdGlvbnMiLCJsb2ciLCJkZWJ1ZyIsInByb3RvY29sIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3BvbnNlIiwicmVzcG9uc2VEZWJ1Z01zZyIsInN0YXR1c0NvZGUiLCJib2R5IiwiRXJyb3IiLCJocmVmIiwidXBsb2FkRmlsZVRvRnRwIiwibG9jYWxGaWxlU3RyZWFtIiwiQiIsInJlc29sdmUiLCJyZWplY3QiLCJGdHAiLCJwdXQiLCJwYXRobmFtZSIsImVyciIsInVwbG9hZEZpbGUiLCJsb2NhbFBhdGgiLCJyZW1vdGVQYXRoIiwiZnMiLCJleGlzdHMiLCJ1cmwiLCJwYXJzZSIsInN0YXQiLCJzaXplIiwiaW5mbyIsInRpbWVTdGFydGVkIiwicHJvY2VzcyIsImhydGltZSIsImluY2x1ZGVzIiwidGltZUVsYXBzZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O1NBR2VBLGdCOzs7OztzREFBZixXQUFpQ0MsU0FBakMsRUFBNENDLGFBQWEsR0FBRyxFQUE1RCxFQUFnRTtBQUM5REMsb0JBQUlDLEtBQUosQ0FBVyxHQUFFSCxTQUFTLENBQUNJLFFBQVMsb0JBQW1CQyxJQUFJLENBQUNDLFNBQUwsQ0FBZUwsYUFBZixDQUE4QixFQUFqRjs7QUFDQSxVQUFNTSxRQUFRLFNBQVMsNkJBQVFOLGFBQVIsQ0FBdkI7QUFDQSxVQUFNTyxnQkFBZ0IsR0FBSSxrQkFBaUJELFFBQVEsQ0FBQ0UsVUFBVyxJQUF0QyxHQUNDLGtCQUFpQkosSUFBSSxDQUFDQyxTQUFMLENBQWVDLFFBQVEsQ0FBQ0csSUFBeEIsQ0FBOEIsRUFEekU7O0FBRUFSLG9CQUFJQyxLQUFKLENBQVVLLGdCQUFWOztBQUNBLFFBQUlELFFBQVEsQ0FBQ0UsVUFBVCxJQUF1QixHQUEzQixFQUFnQztBQUM5QixZQUFNLElBQUlFLEtBQUosQ0FBVyx3Q0FBdUNYLFNBQVMsQ0FBQ1ksSUFBSyxNQUFLSixnQkFBaUIsRUFBdkYsQ0FBTjtBQUNEO0FBQ0YsRzs7OztTQUVjSyxlOzs7OztxREFBZixXQUFnQ0MsZUFBaEMsRUFBaURkLFNBQWpELEVBQTREQyxhQUFhLEdBQUcsRUFBNUUsRUFBZ0Y7QUFDOUVDLG9CQUFJQyxLQUFKLENBQVcsR0FBRUgsU0FBUyxDQUFDSSxRQUFTLG9CQUFtQkMsSUFBSSxDQUFDQyxTQUFMLENBQWVMLGFBQWYsQ0FBOEIsRUFBakY7O0FBQ0EsaUJBQWEsSUFBSWMsaUJBQUosQ0FBTSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdEMsVUFBSUMsY0FBSixDQUFRakIsYUFBUixFQUF1QmtCLEdBQXZCLENBQTJCTCxlQUEzQixFQUE0Q2QsU0FBUyxDQUFDb0IsUUFBdEQsRUFBaUVDLEdBQUQsSUFBUztBQUN2RSxZQUFJQSxHQUFKLEVBQVM7QUFDUCxpQkFBT0osTUFBTSxDQUFDSSxHQUFELENBQWI7QUFDRDs7QUFDREwsUUFBQUEsT0FBTztBQUNSLE9BTEQ7QUFNRCxLQVBZLENBQWI7QUFRRCxHOzs7O1NBWWNNLFU7Ozs7O2dEQUFmLFdBQTJCQyxTQUEzQixFQUFzQ0MsVUFBdEMsRUFBa0R2QixhQUFhLEdBQUcsRUFBbEUsRUFBc0U7QUFDcEUsUUFBSSxRQUFPd0IsYUFBR0MsTUFBSCxDQUFVSCxTQUFWLENBQVAsQ0FBSixFQUFpQztBQUMvQixZQUFNLElBQUlaLEtBQUosQ0FBWSxJQUFHWSxTQUFVLHdDQUF6QixDQUFOO0FBQ0Q7O0FBQ0QsVUFBTXZCLFNBQVMsR0FBRzJCLGFBQUlDLEtBQUosQ0FBVUosVUFBVixDQUFsQjs7QUFKb0UsdUJBSy9DQyxhQUFHSSxJQUFILENBQVFOLFNBQVIsQ0FMK0M7QUFBQSxVQUs3RE8sSUFMNkQsUUFLN0RBLElBTDZEOztBQU1wRTVCLG9CQUFJNkIsSUFBSixDQUFVLGNBQWFSLFNBQVUsUUFBTyxnQ0FBcUJPLElBQXJCLENBQTJCLGFBQVlOLFVBQVcsTUFBMUY7O0FBQ0EsVUFBTVEsV0FBVyxHQUFHQyxPQUFPLENBQUNDLE1BQVIsRUFBcEI7O0FBQ0EsUUFBSSxDQUFDLE9BQUQsRUFBVSxRQUFWLEVBQW9CQyxRQUFwQixDQUE2Qm5DLFNBQVMsQ0FBQ0ksUUFBdkMsQ0FBSixFQUFzRDtBQUNwRCxZQUFNTCxnQkFBZ0IsQ0FBQ0MsU0FBRCxFQUFZQyxhQUFaLENBQXRCO0FBQ0QsS0FGRCxNQUVPLElBQUlELFNBQVMsQ0FBQ0ksUUFBVixLQUF1QixNQUEzQixFQUFtQztBQUN4QyxZQUFNUyxlQUFlLENBQUMsMEJBQWlCVSxTQUFqQixDQUFELEVBQThCdkIsU0FBOUIsRUFBeUNDLGFBQXpDLENBQXJCO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsWUFBTSxJQUFJVSxLQUFKLENBQVcsOEJBQTZCWSxTQUFVLFNBQVFDLFVBQVcsS0FBM0QsR0FDQyxnQ0FBK0J4QixTQUFTLENBQUNJLFFBQVMsS0FEbkQsR0FFQyxrREFGWCxDQUFOO0FBR0Q7O0FBQ0QsVUFBTWdDLFdBQVcsR0FBR0gsT0FBTyxDQUFDQyxNQUFSLENBQWVGLFdBQWYsRUFBNEIsQ0FBNUIsQ0FBcEI7O0FBQ0E5QixvQkFBSTZCLElBQUosQ0FBVSxhQUFZUixTQUFVLFFBQU8sZ0NBQXFCTyxJQUFyQixDQUEyQixZQUFXTSxXQUFZLFVBQVNBLFdBQVcsS0FBSyxDQUFoQixHQUFvQixFQUFwQixHQUF5QixHQUFJLEVBQS9IO0FBQ0QsRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVJlYWRTdHJlYW0gfSBmcm9tICdmcyc7XG5pbXBvcnQgZnMgZnJvbSAnLi9mcyc7XG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyB0b1JlYWRhYmxlU2l6ZVN0cmluZyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCByZXF1ZXN0IGZyb20gJ3JlcXVlc3QtcHJvbWlzZSc7XG5pbXBvcnQgRnRwIGZyb20gJ2pzZnRwJztcblxuXG5hc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlVG9IdHRwIChyZW1vdGVVcmwsIHVwbG9hZE9wdGlvbnMgPSB7fSkge1xuICBsb2cuZGVidWcoYCR7cmVtb3RlVXJsLnByb3RvY29sfSB1cGxvYWQgb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeSh1cGxvYWRPcHRpb25zKX1gKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KHVwbG9hZE9wdGlvbnMpO1xuICBjb25zdCByZXNwb25zZURlYnVnTXNnID0gYFJlc3BvbnNlIGNvZGU6ICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYFJlc3BvbnNlIGJvZHk6ICR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuYm9keSl9YDtcbiAgbG9nLmRlYnVnKHJlc3BvbnNlRGVidWdNc2cpO1xuICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB1cGxvYWQgdGhlIHJlY29yZGVkIG1lZGlhIHRvICcke3JlbW90ZVVybC5ocmVmfScuICR7cmVzcG9uc2VEZWJ1Z01zZ31gKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlVG9GdHAgKGxvY2FsRmlsZVN0cmVhbSwgcmVtb3RlVXJsLCB1cGxvYWRPcHRpb25zID0ge30pIHtcbiAgbG9nLmRlYnVnKGAke3JlbW90ZVVybC5wcm90b2NvbH0gdXBsb2FkIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkodXBsb2FkT3B0aW9ucyl9YCk7XG4gIHJldHVybiBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbmV3IEZ0cCh1cGxvYWRPcHRpb25zKS5wdXQobG9jYWxGaWxlU3RyZWFtLCByZW1vdGVVcmwucGF0aG5hbWUsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVcGxvYWRzIHRoZSBnaXZlbiBmaWxlIHRvIGEgcmVtb3RlIGxvY2F0aW9uLiBIVFRQKFMpIGFuZCBGVFBcbiAqIHByb3RvY29scyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbFBhdGggLSBUaGUgcGF0aCB0byBhIGZpbGUgb24gdGhlIGxvY2FsIHN0b3JhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgVVJMIHRvIHVwbG9hZCB0aGUgZmlsZSB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGxvYWRPcHRpb25zIC0gVGhlIG9wdGlvbnMgc2V0LCB3aGljaCBkZXBlbmRzIG9uIHRoZSBwcm90b2NvbCBzZXQgZm9yIHJlbW90ZVBhdGguXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9yZXF1ZXN0LXByb21pc2UgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2pzZnRwIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGUgKGxvY2FsUGF0aCwgcmVtb3RlUGF0aCwgdXBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKGxvY2FsUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IgKGAnJHtsb2NhbFBhdGh9JyBkb2VzIG5vdCBleGlzdHMgb3IgaXMgbm90IGFjY2Vzc2libGVgKTtcbiAgfVxuICBjb25zdCByZW1vdGVVcmwgPSB1cmwucGFyc2UocmVtb3RlUGF0aCk7XG4gIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQobG9jYWxQYXRoKTtcbiAgbG9nLmluZm8oYFVwbG9hZGluZyAnJHtsb2NhbFBhdGh9JyBvZiAke3RvUmVhZGFibGVTaXplU3RyaW5nKHNpemUpfSBzaXplIHRvICcke3JlbW90ZVBhdGh9Jy4uLmApO1xuICBjb25zdCB0aW1lU3RhcnRlZCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gIGlmIChbJ2h0dHA6JywgJ2h0dHBzOiddLmluY2x1ZGVzKHJlbW90ZVVybC5wcm90b2NvbCkpIHtcbiAgICBhd2FpdCB1cGxvYWRGaWxlVG9IdHRwKHJlbW90ZVVybCwgdXBsb2FkT3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAocmVtb3RlVXJsLnByb3RvY29sID09PSAnZnRwOicpIHtcbiAgICBhd2FpdCB1cGxvYWRGaWxlVG9GdHAoY3JlYXRlUmVhZFN0cmVhbShsb2NhbFBhdGgpLCByZW1vdGVVcmwsIHVwbG9hZE9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVwbG9hZCB0aGUgZmlsZSBhdCAnJHtsb2NhbFBhdGh9JyB0byAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgVW5zdXBwb3J0ZWQgcmVtb3RlIHByb3RvY29sICcke3JlbW90ZVVybC5wcm90b2NvbH0nLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYE9ubHkgaHR0cC9odHRwcyBhbmQgZnRwIHByb3RvY29scyBhcmUgc3VwcG9ydGVkLmApO1xuICB9XG4gIGNvbnN0IHRpbWVFbGFwc2VkID0gcHJvY2Vzcy5ocnRpbWUodGltZVN0YXJ0ZWQpWzBdO1xuICBsb2cuaW5mbyhgVXBsb2FkZWQgJyR7bG9jYWxQYXRofScgb2YgJHt0b1JlYWRhYmxlU2l6ZVN0cmluZyhzaXplKX0gc2l6ZSBpbiAke3RpbWVFbGFwc2VkfSBzZWNvbmQke3RpbWVFbGFwc2VkID09PSAxID8gJycgOiAncyd9YCk7XG59XG5cbmV4cG9ydCB7IHVwbG9hZEZpbGUgfTtcbiJdLCJmaWxlIjoibGliL25ldC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
