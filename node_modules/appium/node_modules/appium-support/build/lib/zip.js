"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAllTo = extractAllTo;
exports.readEntries = readEntries;
exports.toInMemoryZip = toInMemoryZip;
exports._extractEntryTo = _extractEntryTo;
exports.assertValidZip = assertValidZip;
exports.default = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _extractZip = _interopRequireDefault(require("extract-zip"));

var _yauzl = _interopRequireDefault(require("yauzl"));

var _archiver = _interopRequireDefault(require("archiver"));

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _mkdirp = require("../lib/mkdirp");

var _stream = _interopRequireDefault(require("stream"));

var _fs2 = _interopRequireDefault(require("./fs"));

const extract = _bluebird.default.promisify(_extractZip.default);

const open = _bluebird.default.promisify(_yauzl.default.open);

const ZIP_MAGIC = 'PK';

function extractAllTo(_x, _x2) {
  return _extractAllTo.apply(this, arguments);
}

function _extractAllTo() {
  _extractAllTo = (0, _asyncToGenerator2.default)(function* (zipFilePath, destDir) {
    return yield extract(zipFilePath, {
      dir: destDir
    });
  });
  return _extractAllTo.apply(this, arguments);
}

function _extractEntryTo(_x3, _x4, _x5) {
  return _extractEntryTo2.apply(this, arguments);
}

function _extractEntryTo2() {
  _extractEntryTo2 = (0, _asyncToGenerator2.default)(function* (zipFile, entry, destDir) {
    const dstPath = _path.default.resolve(destDir, entry.fileName);

    if (/\/$/.test(entry.fileName)) {
      if (!(yield _fs2.default.exists(dstPath))) {
        yield (0, _mkdirp.mkdirp)(dstPath);
      }

      return;
    } else if (!(yield _fs2.default.exists(_path.default.dirname(dstPath)))) {
      yield (0, _mkdirp.mkdirp)(_path.default.dirname(dstPath));
    }

    const writeStream = (0, _fs.createWriteStream)(dstPath, {
      flags: 'w'
    });
    const writeStreamPromise = new _bluebird.default((resolve, reject) => {
      writeStream.once('finish', resolve);
      writeStream.once('error', reject);
    });
    const zipReadStream = yield new _bluebird.default((resolve, reject) => {
      zipFile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));
    });
    const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
      zipReadStream.once('end', resolve);
      zipReadStream.once('error', reject);
    });
    zipReadStream.pipe(writeStream);
    return yield _bluebird.default.all([zipReadStreamPromise, writeStreamPromise]);
  });
  return _extractEntryTo2.apply(this, arguments);
}

function readEntries(_x6, _x7) {
  return _readEntries.apply(this, arguments);
}

function _readEntries() {
  _readEntries = (0, _asyncToGenerator2.default)(function* (zipFilePath, onEntry) {
    const zipfile = yield open(zipFilePath, {
      lazyEntries: true
    });
    const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
      zipfile.once('end', resolve);
      zipfile.once('error', reject);
      zipfile.on('entry', function () {
        var _ref = (0, _asyncToGenerator2.default)(function* (entry) {
          const res = yield onEntry({
            entry,
            extractEntryTo: function () {
              var _extractEntryTo3 = (0, _asyncToGenerator2.default)(function* (destDir) {
                return yield _extractEntryTo(zipfile, entry, destDir);
              });

              return function extractEntryTo(_x11) {
                return _extractEntryTo3.apply(this, arguments);
              };
            }()
          });

          if (res === false) {
            return zipfile.emit('end');
          }

          zipfile.readEntry();
        });

        return function (_x10) {
          return _ref.apply(this, arguments);
        };
      }());
    });
    zipfile.readEntry();
    return yield zipReadStreamPromise;
  });
  return _readEntries.apply(this, arguments);
}

function toInMemoryZip(_x8) {
  return _toInMemoryZip.apply(this, arguments);
}

function _toInMemoryZip() {
  _toInMemoryZip = (0, _asyncToGenerator2.default)(function* (srcDir) {
    const zipBufferArr = [];
    const zipWriteStream = new _stream.default.Writable({
      write: (buffer, encoding, next) => {
        zipBufferArr.push(buffer);
        next();
      }
    });
    const zipWriteStreamPromise = new _bluebird.default(resolve => {
      zipWriteStream.once('finish', resolve);
    });
    const archive = (0, _archiver.default)('zip', {
      zlib: {
        level: 9
      }
    });
    const archiveStreamPromise = new _bluebird.default((resolve, reject) => {
      archive.once('finish', resolve);
      archive.once('error', errStr => reject(new Error(`Failed to zip directory ${srcDir}: ${errStr}`)));
    });
    archive.directory(srcDir, false);
    archive.pipe(zipWriteStream);
    archive.finalize();
    yield _bluebird.default.all([archiveStreamPromise, zipWriteStreamPromise]);
    return Buffer.concat(zipBufferArr);
  });
  return _toInMemoryZip.apply(this, arguments);
}

function assertValidZip(_x9) {
  return _assertValidZip.apply(this, arguments);
}

function _assertValidZip() {
  _assertValidZip = (0, _asyncToGenerator2.default)(function* (filePath) {
    if (!(yield _fs2.default.exists(filePath))) {
      throw new Error(`The file at '${filePath}' does not exist`);
    }

    const _ref2 = yield _fs2.default.stat(filePath),
          size = _ref2.size;

    if (size < 4) {
      throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);
    }

    const fd = yield _fs2.default.open(filePath, 'r');

    try {
      const buffer = Buffer.alloc(ZIP_MAGIC.length);
      yield _fs2.default.read(fd, buffer, 0, ZIP_MAGIC.length, 0);
      const signature = buffer.toString('ascii');

      if (signature !== ZIP_MAGIC) {
        throw new Error(`The file signature '${signature}' of '${filePath}' ` + `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);
      }

      return true;
    } finally {
      yield _fs2.default.close(fd);
    }
  });
  return _assertValidZip.apply(this, arguments);
}

var _default = {
  extractAllTo,
  readEntries,
  toInMemoryZip,
  assertValidZip
};
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi96aXAuanMiXSwibmFtZXMiOlsiZXh0cmFjdCIsIkIiLCJwcm9taXNpZnkiLCJub2RlRXh0cmFjdCIsIm9wZW4iLCJ5YXV6bCIsIlpJUF9NQUdJQyIsImV4dHJhY3RBbGxUbyIsInppcEZpbGVQYXRoIiwiZGVzdERpciIsImRpciIsIl9leHRyYWN0RW50cnlUbyIsInppcEZpbGUiLCJlbnRyeSIsImRzdFBhdGgiLCJwYXRoIiwicmVzb2x2ZSIsImZpbGVOYW1lIiwidGVzdCIsImZzIiwiZXhpc3RzIiwiZGlybmFtZSIsIndyaXRlU3RyZWFtIiwiZmxhZ3MiLCJ3cml0ZVN0cmVhbVByb21pc2UiLCJyZWplY3QiLCJvbmNlIiwiemlwUmVhZFN0cmVhbSIsIm9wZW5SZWFkU3RyZWFtIiwiZXJyIiwicmVhZFN0cmVhbSIsInppcFJlYWRTdHJlYW1Qcm9taXNlIiwicGlwZSIsImFsbCIsInJlYWRFbnRyaWVzIiwib25FbnRyeSIsInppcGZpbGUiLCJsYXp5RW50cmllcyIsIm9uIiwicmVzIiwiZXh0cmFjdEVudHJ5VG8iLCJlbWl0IiwicmVhZEVudHJ5IiwidG9Jbk1lbW9yeVppcCIsInNyY0RpciIsInppcEJ1ZmZlckFyciIsInppcFdyaXRlU3RyZWFtIiwic3RyZWFtIiwiV3JpdGFibGUiLCJ3cml0ZSIsImJ1ZmZlciIsImVuY29kaW5nIiwibmV4dCIsInB1c2giLCJ6aXBXcml0ZVN0cmVhbVByb21pc2UiLCJhcmNoaXZlIiwiemxpYiIsImxldmVsIiwiYXJjaGl2ZVN0cmVhbVByb21pc2UiLCJlcnJTdHIiLCJFcnJvciIsImRpcmVjdG9yeSIsImZpbmFsaXplIiwiQnVmZmVyIiwiY29uY2F0IiwiYXNzZXJ0VmFsaWRaaXAiLCJmaWxlUGF0aCIsInN0YXQiLCJzaXplIiwiZmQiLCJhbGxvYyIsImxlbmd0aCIsInJlYWQiLCJzaWduYXR1cmUiLCJ0b1N0cmluZyIsImNsb3NlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FB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RyxDQUFYLEVBQWM7QUFDWixZQUFNLElBQUlSLEtBQUosQ0FBVyxnQkFBZU0sUUFBUyxvQ0FBbkMsQ0FBTjtBQUNEOztBQUNELFVBQU1HLEVBQUUsU0FBU2xELGFBQUdmLElBQUgsQ0FBUThELFFBQVIsRUFBa0IsR0FBbEIsQ0FBakI7O0FBQ0EsUUFBSTtBQUNGLFlBQU1oQixNQUFNLEdBQUdhLE1BQU0sQ0FBQ08sS0FBUCxDQUFhaEUsU0FBUyxDQUFDaUUsTUFBdkIsQ0FBZjtBQUNBLFlBQU1wRCxhQUFHcUQsSUFBSCxDQUFRSCxFQUFSLEVBQVluQixNQUFaLEVBQW9CLENBQXBCLEVBQXVCNUMsU0FBUyxDQUFDaUUsTUFBakMsRUFBeUMsQ0FBekMsQ0FBTjtBQUNBLFlBQU1FLFNBQVMsR0FBR3ZCLE1BQU0sQ0FBQ3dCLFFBQVAsQ0FBZ0IsT0FBaEIsQ0FBbEI7O0FBQ0EsVUFBSUQsU0FBUyxLQUFLbkUsU0FBbEIsRUFBNkI7QUFDM0IsY0FBTSxJQUFJc0QsS0FBSixDQUFXLHVCQUFzQmEsU0FBVSxTQUFRUCxRQUFTLElBQWxELEdBQ2IsdURBQXNENUQsU0FBVSxHQUQ3RCxDQUFOO0FBRUQ7O0FBQ0QsYUFBTyxJQUFQO0FBQ0QsS0FURCxTQVNVO0FBQ1IsWUFBTWEsYUFBR3dELEtBQUgsQ0FBU04sRUFBVCxDQUFOO0FBQ0Q7QUFDRixHOzs7O2VBR2M7QUFBRTlELEVBQUFBLFlBQUY7QUFBZ0IyQixFQUFBQSxXQUFoQjtBQUE2QlMsRUFBQUEsYUFBN0I7QUFBNENzQixFQUFBQTtBQUE1QyxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IG5vZGVFeHRyYWN0IGZyb20gJ2V4dHJhY3QtemlwJztcbmltcG9ydCB5YXV6bCBmcm9tICd5YXV6bCc7XG5pbXBvcnQgYXJjaGl2ZXIgZnJvbSAnYXJjaGl2ZXInO1xuaW1wb3J0IHsgY3JlYXRlV3JpdGVTdHJlYW0gfSBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IG1rZGlycCB9IGZyb20gJy4uL2xpYi9ta2RpcnAnO1xuaW1wb3J0IHN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IGZzIGZyb20gJy4vZnMnO1xuXG5jb25zdCBleHRyYWN0ID0gQi5wcm9taXNpZnkobm9kZUV4dHJhY3QpO1xuY29uc3Qgb3BlbiA9IEIucHJvbWlzaWZ5KHlhdXpsLm9wZW4pO1xuY29uc3QgWklQX01BR0lDID0gJ1BLJztcblxuLyoqXG4gKiBFeHRyYWN0IHppcGZpbGUgdG8gYSBkaXJlY3RvcnlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZVBhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgc291cmNlIFpJUCBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEFsbFRvICh6aXBGaWxlUGF0aCwgZGVzdERpcikge1xuICByZXR1cm4gYXdhaXQgZXh0cmFjdCh6aXBGaWxlUGF0aCwge2RpcjogZGVzdERpcn0pO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBzaW5nbGUgemlwIGVudHJ5IHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHtTdHJlYW1hYmxlfSB6aXBGaWxlIFRoZSBzb3VyY2UgWklQIHN0cmVhbVxuICogQHBhcmFtIHt5YXV6bC5aaXBFbnRyeX0gZW50cnkgVGhlIGVudHJ5IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2V4dHJhY3RFbnRyeVRvICh6aXBGaWxlLCBlbnRyeSwgZGVzdERpcikge1xuICBjb25zdCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKGRlc3REaXIsIGVudHJ5LmZpbGVOYW1lKTtcblxuICAvLyBDcmVhdGUgZGVzdCBkaXJlY3RvcnkgaWYgZG9lc24ndCBleGlzdCBhbHJlYWR5XG4gIGlmICgvXFwvJC8udGVzdChlbnRyeS5maWxlTmFtZSkpIHtcbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhkc3RQYXRoKSkge1xuICAgICAgYXdhaXQgbWtkaXJwKGRzdFBhdGgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwYXRoLmRpcm5hbWUoZHN0UGF0aCkpKSB7XG4gICAgYXdhaXQgbWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSB3cml0ZSBzdHJlYW1cbiAgY29uc3Qgd3JpdGVTdHJlYW0gPSBjcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoLCB7ZmxhZ3M6ICd3J30pO1xuICBjb25zdCB3cml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZXJyb3InLCByZWplY3QpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgemlwUmVhZFN0cmVhbSBhbmQgcGlwZSBkYXRhIHRvIHRoZSB3cml0ZSBzdHJlYW1cbiAgLy8gKGZvciBzb21lIG9kZCByZWFzb24gQi5wcm9taXNpZnkgZG9lc24ndCB3b3JrIG9uIHppcGZpbGUub3BlblJlYWRTdHJlYW0sIGl0IGNhdXNlcyBhbiBlcnJvciAnY2xvc2VkJylcbiAgY29uc3QgemlwUmVhZFN0cmVhbSA9IGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB6aXBGaWxlLm9wZW5SZWFkU3RyZWFtKGVudHJ5LCAoZXJyLCByZWFkU3RyZWFtKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVhZFN0cmVhbSkpO1xuICB9KTtcbiAgY29uc3QgemlwUmVhZFN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgemlwUmVhZFN0cmVhbS5vbmNlKCdlbmQnLCByZXNvbHZlKTtcbiAgICB6aXBSZWFkU3RyZWFtLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgfSk7XG4gIHppcFJlYWRTdHJlYW0ucGlwZSh3cml0ZVN0cmVhbSk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIHppcFJlYWRTdHJlYW0gYW5kIHdyaXRlU3RyZWFtIHRvIGVuZCBiZWZvcmUgcmV0dXJuaW5nXG4gIHJldHVybiBhd2FpdCBCLmFsbChbXG4gICAgemlwUmVhZFN0cmVhbVByb21pc2UsXG4gICAgd3JpdGVTdHJlYW1Qcm9taXNlLFxuICBdKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBaaXBFbnRyeVxuICogQHByb3BlcnR5IHt5YXV6bC5aaXBFbnRyeX0gZW50cnkgVGhlIGFjdHVhbCBlbnRyeSBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZXh0cmFjdEVudHJ5VG8gQW4gYXN5bmMgZnVuY3Rpb24sIHdoaWNoIGFjY2VwdHMgb25lIHBhcmFtZXRlci5cbiAqIFRoaXMgcGFyYW1ldGVyIGNvbnRhaW5zIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIgcGF0aCB0byB3aGljaCB0aGlzIGZ1bmN0aW9uIGlzIGdvaW5nIHRvIGV4dHJhY3QgdGhlIGVudHJ5LlxuICovXG5cbi8qKlxuICogR2V0IGVudHJpZXMgZm9yIGEgemlwIGZvbGRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB6aXBGaWxlUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBzb3VyY2UgWklQIGZpbGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uRW50cnkgQ2FsbGJhY2sgd2hlbiBlbnRyeSBpcyByZWFkLlxuICogVGhlIGNhbGxiYWNrIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBvbmUgYXJndW1lbnQgb2YgWmlwRW50cnkgdHlwZS5cbiAqIFRoZSBpdGVyYXRpb24gdGhyb3VnaCB0aGUgc291cmNlIHppcCBmaWxlIHdpbGwgYmkgdGVybWluYXRlZCBhcyBzb29uIGFzXG4gKiB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gZXF1YWxzIHRvIGBmYWxzZWAuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRFbnRyaWVzICh6aXBGaWxlUGF0aCwgb25FbnRyeSkge1xuICAvLyBPcGVuIGEgemlwIGZpbGUgYW5kIHN0YXJ0IHJlYWRpbmcgZW50cmllc1xuICBjb25zdCB6aXBmaWxlID0gYXdhaXQgb3Blbih6aXBGaWxlUGF0aCwge2xhenlFbnRyaWVzOiB0cnVlfSk7XG4gIGNvbnN0IHppcFJlYWRTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHppcGZpbGUub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgemlwZmlsZS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICAvLyBPbiBlYWNoIGVudHJ5LCBjYWxsICdvbkVudHJ5JyBhbmQgdGhlbiByZWFkIHRoZSBuZXh0IGVudHJ5XG4gICAgemlwZmlsZS5vbignZW50cnknLCBhc3luYyAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG9uRW50cnkoe1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgZXh0cmFjdEVudHJ5VG86IGFzeW5jIChkZXN0RGlyKSA9PiBhd2FpdCBfZXh0cmFjdEVudHJ5VG8oemlwZmlsZSwgZW50cnksIGRlc3REaXIpXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB6aXBmaWxlLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHppcGZpbGUucmVhZEVudHJ5KCk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIGVudHJpZXMgdG8gZmluaXNoIGJlaW5nIGl0ZXJhdGVkIHRocm91Z2hcbiAgcmV0dXJuIGF3YWl0IHppcFJlYWRTdHJlYW1Qcm9taXNlO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGNvbnRlbnRzIG9mIGxvY2FsIGRpcmVjdG9yeSB0byBhbiBpbi1tZW1vcnkgLnppcCBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjRGlyIFRoZSBmdWxsIHBhdGggdG8gdGhlIGZvbGRlciBiZWluZyB6aXBwZWRcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFppcHBlZCBjb250ZW50IG9mIHRoZSBzb3VyY2UgZm9sZGVyIGFzIG1lbW9yeSBidWZmZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdG9Jbk1lbW9yeVppcCAoc3JjRGlyKSB7XG4gIC8vIENyZWF0ZSBhIHdyaXRhYmxlIHN0cmVhbSB0aGF0IHppcCBidWZmZXJzIHdpbGwgYmUgc3RyZWFtZWQgdG9cbiAgY29uc3QgemlwQnVmZmVyQXJyID0gW107XG4gIGNvbnN0IHppcFdyaXRlU3RyZWFtID0gbmV3IHN0cmVhbS5Xcml0YWJsZSh7XG4gICAgd3JpdGU6IChidWZmZXIsIGVuY29kaW5nLCBuZXh0KSA9PiB7XG4gICAgICB6aXBCdWZmZXJBcnIucHVzaChidWZmZXIpO1xuICAgICAgbmV4dCgpO1xuICAgIH0sXG4gIH0pO1xuICBjb25zdCB6aXBXcml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSkgPT4ge1xuICAgIC8vIERvbid0IG5lZWQgdG8gZG8gZXJyb3IgaGFuZGxpbmcgc2luY2UgdGhpcyB3cml0ZVN0cmVhbSBpcyBpbi1tZW1vcnkgYW5kIGRvZXNuJ3QgZW1pdCBhbnkgZXJyb3JzXG4gICAgemlwV3JpdGVTdHJlYW0ub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gIH0pO1xuXG4gIC8vIFppcCAnc3JjRGlyJyBhbmQgc3RyZWFtIGl0IHRvIHRoZSBhYm92ZSB3cml0YWJsZSBzdHJlYW1cbiAgY29uc3QgYXJjaGl2ZSA9IGFyY2hpdmVyKCd6aXAnLCB7XG4gICAgemxpYjoge2xldmVsOiA5fVxuICB9KTtcbiAgY29uc3QgYXJjaGl2ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXJjaGl2ZS5vbmNlKCdmaW5pc2gnLCByZXNvbHZlKTtcbiAgICBhcmNoaXZlLm9uY2UoJ2Vycm9yJywgKGVyclN0cikgPT4gcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIHppcCBkaXJlY3RvcnkgJHtzcmNEaXJ9OiAke2VyclN0cn1gKSkpO1xuICB9KTtcbiAgYXJjaGl2ZS5kaXJlY3Rvcnkoc3JjRGlyLCBmYWxzZSk7XG4gIGFyY2hpdmUucGlwZSh6aXBXcml0ZVN0cmVhbSk7XG4gIGFyY2hpdmUuZmluYWxpemUoKTtcblxuICAvLyBXYWl0IGZvciB0aGUgc3RyZWFtcyB0byBmaW5pc2hcbiAgYXdhaXQgQi5hbGwoW2FyY2hpdmVTdHJlYW1Qcm9taXNlLCB6aXBXcml0ZVN0cmVhbVByb21pc2VdKTtcblxuICAvLyBSZXR1cm4gdGhlIGFycmF5IG9mIHppcCBidWZmZXJzIGNvbmNhdGVuYXRlZCBpbnRvIG9uZSBidWZmZXJcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoemlwQnVmZmVyQXJyKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB3aGV0aGVyIHRoZSBnaXZlbiBmaWxlIGlzIGEgdmFsaWQgWklQIGFyY2hpdmVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggLSBGdWxsIHBhdGggdG8gdGhlIGZpbGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYSB2YWxpZCBaSVAgYXJjaGl2ZVxuICovXG5hc3luYyBmdW5jdGlvbiBhc3NlcnRWYWxpZFppcCAoZmlsZVBhdGgpIHtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMoZmlsZVBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBhdCAnJHtmaWxlUGF0aH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cblxuICBjb25zdCB7c2l6ZX0gPSBhd2FpdCBmcy5zdGF0KGZpbGVQYXRoKTtcbiAgaWYgKHNpemUgPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBhdCAnJHtmaWxlUGF0aH0nIGlzIHRvbyBzbWFsbCB0byBiZSBhIFpJUCBhcmNoaXZlYCk7XG4gIH1cbiAgY29uc3QgZmQgPSBhd2FpdCBmcy5vcGVuKGZpbGVQYXRoLCAncicpO1xuICB0cnkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhaSVBfTUFHSUMubGVuZ3RoKTtcbiAgICBhd2FpdCBmcy5yZWFkKGZkLCBidWZmZXIsIDAsIFpJUF9NQUdJQy5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJ1ZmZlci50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoc2lnbmF0dXJlICE9PSBaSVBfTUFHSUMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpbGUgc2lnbmF0dXJlICcke3NpZ25hdHVyZX0nIG9mICcke2ZpbGVQYXRofScgYCArXG4gICAgICAgIGBpcyBub3QgZXF1YWwgdG8gdGhlIGV4cGVjdGVkIFpJUCBhcmNoaXZlIHNpZ25hdHVyZSAnJHtaSVBfTUFHSUN9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5jbG9zZShmZCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgZXh0cmFjdEFsbFRvLCByZWFkRW50cmllcywgdG9Jbk1lbW9yeVppcCwgX2V4dHJhY3RFbnRyeVRvLCBhc3NlcnRWYWxpZFppcCB9O1xuZXhwb3J0IGRlZmF1bHQgeyBleHRyYWN0QWxsVG8sIHJlYWRFbnRyaWVzLCB0b0luTWVtb3J5WmlwLCBhc3NlcnRWYWxpZFppcCB9O1xuIl0sImZpbGUiOiJsaWIvemlwLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
