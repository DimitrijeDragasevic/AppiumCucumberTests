"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ADB_EXEC_TIMEOUT = exports.default = void 0;

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger.js"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _helpers = require("../helpers");

var _teen_process = require("teen_process");

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

var _shellQuote = require("shell-quote");

let systemCallMethods = {};
const DEFAULT_ADB_EXEC_TIMEOUT = 20000;
exports.DEFAULT_ADB_EXEC_TIMEOUT = DEFAULT_ADB_EXEC_TIMEOUT;
const DEFAULT_ADB_REBOOT_RETRIES = 90;
const LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
const PROTOCOL_FAULT_ERROR_REGEXP = new RegExp('protocol fault \\(no status\\)', 'i');
const DEVICE_NOT_FOUND_ERROR_REGEXP = new RegExp(`error: device ('.+' )?not found`, 'i');
const DEVICE_CONNECTING_ERROR_REGEXP = new RegExp('error: device still connecting', 'i');
const CERTS_ROOT = '/system/etc/security/cacerts';
systemCallMethods.getSdkBinaryPath = _lodash.default.memoize(async function (binaryName) {
  _logger.default.info(`Checking whether ${binaryName} is present`);

  if (this.sdkRoot) {
    return await this.getBinaryFromSdkRoot(binaryName);
  }

  _logger.default.warn(`The ANDROID_HOME environment variable is not set to the Android SDK ` + `root directory path. ANDROID_HOME is required for compatibility ` + `with SDK 23+. Checking along PATH for ${binaryName}.`);

  return await this.getBinaryFromPath(binaryName);
});
systemCallMethods.getCommandForOS = _lodash.default.memoize(function () {
  return _appiumSupport.system.isWindows() ? 'where' : 'which';
});
systemCallMethods.getBinaryNameForOS = _lodash.default.memoize(function (binaryName) {
  if (!_appiumSupport.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].indexOf(binaryName) >= 0 && !binaryName.toLowerCase().endsWith('.bat')) {
    return `${binaryName}.bat`;
  }

  if (!binaryName.toLowerCase().endsWith('.exe')) {
    return `${binaryName}.exe`;
  }

  return binaryName;
});
systemCallMethods.getBinaryFromSdkRoot = _lodash.default.memoize(async function (binaryName) {
  let binaryLoc = null;
  binaryName = this.getBinaryNameForOS(binaryName);
  let binaryLocs = [_path.default.resolve(this.sdkRoot, "platform-tools", binaryName), _path.default.resolve(this.sdkRoot, "emulator", binaryName), _path.default.resolve(this.sdkRoot, "tools", binaryName), _path.default.resolve(this.sdkRoot, "tools", "bin", binaryName)];

  _lodash.default.forEach((await (0, _helpers.getBuildToolsDirs)(this.sdkRoot)), dir => binaryLocs.push(_path.default.resolve(dir, binaryName)));

  for (let loc of binaryLocs) {
    if (await _appiumSupport.fs.exists(loc)) {
      binaryLoc = loc;
      break;
    }
  }

  if (_lodash.default.isNull(binaryLoc)) {
    throw new Error(`Could not find ${binaryName} in ${binaryLocs}. ` + `Do you have the Android SDK installed at '${this.sdkRoot}'?`);
  }

  binaryLoc = binaryLoc.trim();

  _logger.default.info(`Using ${binaryName} from ${binaryLoc}`);

  return binaryLoc;
});

systemCallMethods.getBinaryFromPath = async function (binaryName) {
  let binaryLoc = null;
  let cmd = this.getCommandForOS();

  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(cmd, [binaryName]);

    _logger.default.info(`Using ${binaryName} from ${stdout}`);

    binaryLoc = stdout.trim();
    return binaryLoc;
  } catch (e) {
    throw new Error(`Could not find ${binaryName} Please set the ANDROID_HOME ` + `environment variable with the Android SDK root directory path.`);
  }
};

systemCallMethods.getConnectedDevices = async function () {
  _logger.default.debug("Getting connected devices...");

  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, this.executable.defaultArgs.concat(['devices']));
    let startingIndex = stdout.indexOf("List of devices");

    if (startingIndex === -1) {
      throw new Error(`Unexpected output while trying to get devices. output was: ${stdout}`);
    }

    stdout = stdout.slice(startingIndex);
    let devices = [];

    for (let line of stdout.split("\n")) {
      if (line.trim() !== "" && line.indexOf("List of devices") === -1 && line.indexOf("adb server") === -1 && line.indexOf("* daemon") === -1 && line.indexOf("offline") === -1) {
        let lineInfo = line.split("\t");
        devices.push({
          udid: lineInfo[0],
          state: lineInfo[1]
        });
      }
    }

    _logger.default.debug(`${devices.length} device(s) connected`);

    return devices;
  } catch (e) {
    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);
  }
};

systemCallMethods.getDevicesWithRetry = async function (timeoutMs = 20000) {
  let start = Date.now();

  _logger.default.debug("Trying to find a connected android device");

  let getDevices = async () => {
    if (Date.now() - start > timeoutMs) {
      throw new Error("Could not find a connected Android device.");
    }

    try {
      let devices = await this.getConnectedDevices();

      if (devices.length < 1) {
        _logger.default.debug("Could not find devices, restarting adb server...");

        await this.restartAdb();
        await (0, _asyncbox.sleep)(200);
        return await getDevices();
      }

      return devices;
    } catch (e) {
      _logger.default.debug("Could not find devices, restarting adb server...");

      await this.restartAdb();
      await (0, _asyncbox.sleep)(200);
      return await getDevices();
    }
  };

  return await getDevices();
};

systemCallMethods.restartAdb = async function () {
  if (this.suppressKillServer) {
    _logger.default.debug(`Not restarting abd since 'suppressKillServer' is on`);

    return;
  }

  _logger.default.debug('Restarting adb');

  try {
    await this.killServer();
  } catch (e) {
    _logger.default.error("Error killing ADB server, going to see if it's online anyway");
  }
};

systemCallMethods.killServer = async function () {
  _logger.default.debug(`Killing adb server on port ${this.adbPort}`);

  await (0, _teen_process.exec)(this.executable.path, [...this.executable.defaultArgs, 'kill-server']);
};

systemCallMethods.resetTelnetAuthToken = _lodash.default.memoize(async function () {
  const homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

  if (!homeFolderPath) {
    _logger.default.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  const dstPath = _path.default.resolve(homeFolderPath, '.emulator_console_auth_token');

  _logger.default.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);

  try {
    await _appiumSupport.fs.writeFile(dstPath, '');
  } catch (e) {
    _logger.default.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  return true;
});

systemCallMethods.adbExecEmu = async function (cmd) {
  await this.verifyEmulatorConnected();
  await this.resetTelnetAuthToken();
  await this.adbExec(['emu', ...cmd]);
};

systemCallMethods.adbExec = async function (cmd, opts = {}) {
  if (!cmd) {
    throw new Error("You need to pass in a command to adbExec()");
  }

  opts.timeout = opts.timeout || this.adbExecTimeout || DEFAULT_ADB_EXEC_TIMEOUT;

  let execFunc = async () => {
    try {
      if (!(cmd instanceof Array)) {
        cmd = [cmd];
      }

      let args = this.executable.defaultArgs.concat(cmd);

      _logger.default.debug(`Running '${this.executable.path} ${(0, _shellQuote.quote)(args)}'`);

      let {
        stdout
      } = await (0, _teen_process.exec)(this.executable.path, args, opts);
      stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      return stdout;
    } catch (e) {
      const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;
      const protocolFaultError = PROTOCOL_FAULT_ERROR_REGEXP.test(errText);
      const deviceNotFoundError = DEVICE_NOT_FOUND_ERROR_REGEXP.test(errText);
      const deviceConnectingError = DEVICE_CONNECTING_ERROR_REGEXP.test(errText);

      if (protocolFaultError || deviceNotFoundError || deviceConnectingError) {
        _logger.default.info(`Error sending command, reconnecting device and retrying: ${cmd}`);

        await (0, _asyncbox.sleep)(1000);
        await this.getDevicesWithRetry();
      }

      if (e.code === 0 && e.stdout) {
        let stdout = e.stdout;
        stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
        return stdout;
      }

      throw new Error(`Error executing adbExec. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
    }
  };

  return await (0, _asyncbox.retry)(2, execFunc);
};

systemCallMethods.shell = async function (cmd, opts = {}) {
  const {
    privileged,
    keepPrivileged
  } = opts;
  let shouldRestoreUser = false;

  if (privileged) {
    try {
      shouldRestoreUser = !(await this.adbExec(['root'], opts)).includes('already running as root');
    } catch (err) {
      if (!err.message.includes('adbd cannot run as root')) {
        _logger.default.warn(`Cannot run adbd as root. Original error: ${err.message}`);
      }
    }
  }

  let didCommandFail = false;

  try {
    try {
      return await this.adbExec(_lodash.default.isArray(cmd) ? ['shell', ...cmd] : ['shell', cmd], opts);
    } catch (err) {
      didCommandFail = true;
      throw err;
    }
  } finally {
    if (privileged && shouldRestoreUser && (!keepPrivileged || didCommandFail)) {
      try {
        await this.adbExec(['unroot'], opts);
      } catch (err) {
        _logger.default.warn(`Cannot run adbd as non-root. Original error: ${err.message}`);
      }
    }
  }
};

systemCallMethods.createSubProcess = function (args = []) {
  args = this.executable.defaultArgs.concat(args);

  _logger.default.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);

  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

systemCallMethods.getAdbServerPort = function () {
  return this.adbPort;
};

systemCallMethods.getEmulatorPort = async function () {
  _logger.default.debug("Getting running emulator port");

  if (this.emulatorPort !== null) {
    return this.emulatorPort;
  }

  try {
    let devices = await this.getConnectedDevices();
    let port = this.getPortFromEmulatorString(devices[0].udid);

    if (port) {
      return port;
    } else {
      throw new Error(`Emulator port not found`);
    }
  } catch (e) {
    throw new Error(`No devices connected. Original error: ${e.message}`);
  }
};

systemCallMethods.getPortFromEmulatorString = function (emStr) {
  let portPattern = /emulator-(\d+)/;

  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }

  return false;
};

systemCallMethods.getConnectedEmulators = async function () {
  _logger.default.debug("Getting connected emulators");

  try {
    let devices = await this.getConnectedDevices();
    let emulators = [];

    for (let device of devices) {
      let port = this.getPortFromEmulatorString(device.udid);

      if (port) {
        device.port = port;
        emulators.push(device);
      }
    }

    _logger.default.debug(`${emulators.length} emulator(s) connected`);

    return emulators;
  } catch (e) {
    throw new Error(`Error getting emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.setEmulatorPort = function (emPort) {
  this.emulatorPort = emPort;
};

systemCallMethods.setDeviceId = function (deviceId) {
  _logger.default.debug(`Setting device id to ${deviceId}`);

  this.curDeviceId = deviceId;
  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');

  if (argsHasDevice !== -1) {
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }

  this.executable.defaultArgs.push('-s', deviceId);
};

systemCallMethods.setDevice = function (deviceObj) {
  let deviceId = deviceObj.udid;
  let emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

systemCallMethods.getRunningAVD = async function (avdName) {
  _logger.default.debug(`Trying to find ${avdName} emulator`);

  try {
    let emulators = await this.getConnectedEmulators();

    for (let emulator of emulators) {
      this.setEmulatorPort(emulator.port);
      let runningAVDName = await this.sendTelnetCommand("avd name");

      if (avdName === runningAVDName) {
        _logger.default.debug(`Found emulator ${avdName} in port ${emulator.port}`);

        this.setDeviceId(emulator.udid);
        return emulator;
      }
    }

    _logger.default.debug(`Emulator ${avdName} not running`);

    return null;
  } catch (e) {
    throw new Error(`Error getting AVD. Original error: ${e.message}`);
  }
};

systemCallMethods.getRunningAVDWithRetry = async function (avdName, timeoutMs = 20000) {
  let runningAvd;

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        runningAvd = await this.getRunningAVD(avdName.replace('@', ''));
        return runningAvd;
      } catch (e) {
        _logger.default.debug(e.message);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 1000
    });
  } catch (e) {
    throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);
  }

  return runningAvd;
};

systemCallMethods.killAllEmulators = async function () {
  let cmd, args;

  if (_appiumSupport.system.isWindows()) {
    cmd = 'TASKKILL';
    args = ['TASKKILL', '/IM', 'emulator.exe'];
  } else {
    cmd = '/usr/bin/killall';
    args = ['-m', 'emulator*'];
  }

  try {
    await (0, _teen_process.exec)(cmd, args);
  } catch (e) {
    throw new Error(`Error killing emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.killEmulator = async function (avdName = null, timeout = 60000) {
  if (_appiumSupport.util.hasValue(avdName)) {
    _logger.default.debug(`Killing avd '${avdName}'`);

    const device = await this.getRunningAVD(avdName);

    if (!device) {
      _logger.default.info(`No avd with name '${avdName}' running. Skipping kill step.`);

      return false;
    }
  } else {
    _logger.default.debug(`Killing avd with id '${this.curDeviceId}'`);

    if (!(await this.isEmulatorConnected())) {
      _logger.default.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);

      return false;
    }
  }

  await this.adbExec(['emu', 'kill']);

  _logger.default.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        return _appiumSupport.util.hasValue(avdName) ? !(await this.getRunningAVD(avdName)) : !(await this.isEmulatorConnected());
      } catch (ign) {}

      return false;
    }, {
      waitMs: timeout,
      intervalMs: 2000
    });
  } catch (e) {
    throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);
  }

  _logger.default.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);

  return true;
};

systemCallMethods.launchAVD = async function (avdName, avdArgs, language, country, avdLaunchTimeout = 60000, avdReadyTimeout = 60000, retryTimes = 1) {
  _logger.default.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` + `${avdLaunchTimeout}ms and readyTimeout ${avdReadyTimeout}ms`);

  let emulatorBinaryPath = await this.getSdkBinaryPath("emulator");

  if (avdName[0] === "@") {
    avdName = avdName.substr(1);
  }

  await this.checkAvdExist(avdName);
  let launchArgs = ["-avd", avdName];

  if (_lodash.default.isString(language)) {
    _logger.default.debug(`Setting Android Device Language to ${language}`);

    launchArgs.push("-prop", `persist.sys.language=${language.toLowerCase()}`);
  }

  if (_lodash.default.isString(country)) {
    _logger.default.debug(`Setting Android Device Country to ${country}`);

    launchArgs.push("-prop", `persist.sys.country=${country.toUpperCase()}`);
  }

  let locale;

  if (_lodash.default.isString(language) && _lodash.default.isString(country)) {
    locale = language.toLowerCase() + "-" + country.toUpperCase();
  } else if (_lodash.default.isString(language)) {
    locale = language.toLowerCase();
  } else if (_lodash.default.isString(country)) {
    locale = country;
  }

  if (_lodash.default.isString(locale)) {
    _logger.default.debug(`Setting Android Device Locale to ${locale}`);

    launchArgs.push("-prop", `persist.sys.locale=${locale}`);
  }

  if (!_lodash.default.isEmpty(avdArgs)) {
    launchArgs.push(...(_lodash.default.isArray(avdArgs) ? avdArgs : avdArgs.split(' ')));
  }

  _logger.default.debug(`Running '${emulatorBinaryPath}' with args: ${JSON.stringify(launchArgs)}`);

  let proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
  await proc.start(0);
  proc.on('output', (stdout, stderr) => {
    for (let line of (stdout || stderr || '').split('\n').filter(Boolean)) {
      _logger.default.info(`[AVD OUTPUT] ${line}`);
    }
  });
  proc.on('die', (code, signal) => {
    _logger.default.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);
  });
  await (0, _asyncbox.retry)(retryTimes, async () => await this.getRunningAVDWithRetry(avdName, avdLaunchTimeout));
  await this.waitForEmulatorReady(avdReadyTimeout);
  return proc;
};

systemCallMethods.getAdbVersion = _lodash.default.memoize(async function () {
  try {
    let adbVersion = (await this.adbExec('version')).replace(/Android\sDebug\sBridge\sversion\s([\d.]*)[\s\w-]*/, "$1");
    let parts = adbVersion.split('.');
    return {
      versionString: adbVersion,
      versionFloat: parseFloat(adbVersion),
      major: parseInt(parts[0], 10),
      minor: parseInt(parts[1], 10),
      patch: parts[2] ? parseInt(parts[2], 10) : undefined
    };
  } catch (e) {
    throw new Error(`Error getting adb version. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
  }
});

systemCallMethods.checkAvdExist = async function (avdName) {
  let cmd, result;

  try {
    cmd = await this.getSdkBinaryPath('emulator');
    result = await (0, _teen_process.exec)(cmd, ['-list-avds']);
  } catch (e) {
    let unknownOptionError = new RegExp("unknown option: -list-avds", "i").test(e.stderr);

    if (!unknownOptionError) {
      throw new Error(`Error executing checkAvdExist. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
    }

    const sdkVersion = await (0, _helpers.getSdkToolsVersion)();
    let binaryName = 'android';

    if (sdkVersion) {
      if (sdkVersion.major >= 25) {
        binaryName = 'avdmanager';
      }
    } else {
      _logger.default.warn(`Defaulting binary name to '${binaryName}', because SDK version cannot be parsed`);
    }

    cmd = await this.getSdkBinaryPath(binaryName);
    result = await (0, _teen_process.exec)(cmd, ['list', 'avd', '-c']);
  }

  if (result.stdout.indexOf(avdName) === -1) {
    let existings = `(${result.stdout.trim().replace(/[\n]/g, '), (')})`;
    throw new Error(`Avd '${avdName}' is not available. please select your avd name from one of these: '${existings}'`);
  }
};

systemCallMethods.waitForEmulatorReady = async function (timeoutMs = 20000) {
  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        if (!(await this.shell(['getprop', 'init.svc.bootanim'])).includes('stopped')) {
          return false;
        }

        return /\d+\[\w+\]/.test((await this.shell(['pm', 'get-install-location'])));
      } catch (err) {
        _logger.default.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 3000
    });
  } catch (e) {
    throw new Error(`Emulator is not ready within ${timeoutMs}ms`);
  }
};

systemCallMethods.waitForDevice = async function (appDeviceReadyTimeout = 30) {
  this.appDeviceReadyTimeout = appDeviceReadyTimeout;
  const retries = 3;
  const timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
  await (0, _asyncbox.retry)(retries, async () => {
    try {
      await this.adbExec('wait-for-device', {
        timeout
      });
      await this.ping();
    } catch (e) {
      await this.restartAdb();
      await this.getConnectedDevices();
      throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);
    }
  });
};

systemCallMethods.reboot = async function (retries = DEFAULT_ADB_REBOOT_RETRIES) {
  await this.shell(['stop'], {
    privileged: true
  });
  await _bluebird.default.delay(2000);
  await this.setDeviceProperty('sys.boot_completed', 0);
  await this.shell(['start'], {
    privileged: true
  });
  const started = process.hrtime();
  await (0, _asyncbox.retryInterval)(retries, 1000, async () => {
    if ((await this.getDeviceProperty('sys.boot_completed')) === '1') {
      return;
    }

    const msg = `Reboot is not completed after ${process.hrtime(started)[0]}s`;

    _logger.default.debug(msg);

    throw new Error(msg);
  });
};

systemCallMethods.root = async function () {
  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, ['root']);

    if (stdout && stdout.indexOf('adbd cannot run as root') !== -1) {
      throw new Error(stdout.trim());
    }

    return true;
  } catch (err) {
    _logger.default.warn(`Unable to root adb daemon: '${err.message}'. Continuing`);

    return false;
  }
};

systemCallMethods.unroot = async function () {
  try {
    await (0, _teen_process.exec)(this.executable.path, ['unroot']);
    return true;
  } catch (err) {
    _logger.default.warn(`Unable to unroot adb daemon: '${err.message}'. Continuing`);

    return false;
  }
};

systemCallMethods.isRoot = async function () {
  return (await this.shell(['whoami'])).trim() === 'root';
};

systemCallMethods.fileExists = async function (remotePath) {
  let files = await this.ls(remotePath);
  return files.length > 0;
};

systemCallMethods.ls = async function (remotePath, opts = []) {
  try {
    let args = ['ls', ...opts, remotePath];
    let stdout = await this.shell(args);
    let lines = stdout.split("\n");
    return lines.map(l => l.trim()).filter(Boolean).filter(l => l.indexOf("No such file") === -1);
  } catch (err) {
    if (err.message.indexOf('No such file or directory') === -1) {
      throw err;
    }

    return [];
  }
};

systemCallMethods.fileSize = async function (remotePath) {
  try {
    const files = await this.ls(remotePath, ['-la']);

    if (files.length !== 1) {
      throw new Error(`Remote path is not a file`);
    }

    const match = /[rwxsStT\-+]{10}[\s\d]*\s[^\s]+\s+[^\s]+\s+(\d+)/.exec(files[0]);

    if (!match || _lodash.default.isNaN(parseInt(match[1], 10))) {
      throw new Error(`Unable to parse size from list output: '${files[0]}'`);
    }

    return parseInt(match[1], 10);
  } catch (err) {
    throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);
  }
};

systemCallMethods.installMitmCertificate = async function (cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();

  try {
    const srcCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(srcCert, cert);
    let {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]);
    const certHash = stdout.trim();

    _logger.default.debug(`Got certificate hash: ${certHash}`);

    _logger.default.debug('Preparing certificate content');

    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert], {
      isBuffer: true
    }));
    let dstCertContent = stdout;
    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert, '-text', '-fingerprint', '-noout'], {
      isBuffer: true
    }));
    dstCertContent = Buffer.concat([dstCertContent, stdout]);

    const dstCert = _path.default.resolve(tmpRoot, `${certHash}.0`);

    await _appiumSupport.fs.writeFile(dstCert, dstCertContent);

    _logger.default.debug('Remounting /system in rw mode');

    await (0, _asyncbox.retryInterval)(5, 2000, async () => await this.adbExec(['remount']));

    _logger.default.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);

    await this.push(dstCert, CERTS_ROOT);

    _logger.default.debug('Remounting /system to confirm changes');

    await this.adbExec(['remount']);
  } catch (err) {
    throw new Error(`Cannot inject the custom certificate. ` + `Is the certificate properly encoded into base64-string? ` + `Do you have root permissions on the device? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }
};

systemCallMethods.isMitmCertificateInstalled = async function (cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();
  let certHash;

  try {
    const tmpCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(tmpCert, cert);
    const {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]);
    certHash = stdout.trim();
  } catch (err) {
    throw new Error(`Cannot retrieve the certificate hash. ` + `Is the certificate properly encoded into base64-string? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }

  const dstPath = _path.default.posix.resolve(CERTS_ROOT, `${certHash}.0`);

  _logger.default.debug(`Checking if the certificate is already installed at '${dstPath}'`);

  return await this.fileExists(dstPath);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOlsic3lzdGVtQ2FsbE1ldGhvZHMiLCJERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQiLCJERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyIsIkxJTktFUl9XQVJOSU5HX1JFR0VYUCIsIlBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUCIsIlJlZ0V4cCIsIkRFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQIiwiREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQIiwiQ0VSVFNfUk9PVCIsImdldFNka0JpbmFyeVBhdGgiLCJfIiwibWVtb2l6ZSIsImJpbmFyeU5hbWUiLCJsb2ciLCJpbmZvIiwic2RrUm9vdCIsImdldEJpbmFyeUZyb21TZGtSb290Iiwid2FybiIsImdldEJpbmFyeUZyb21QYXRoIiwiZ2V0Q29tbWFuZEZvck9TIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiZ2V0QmluYXJ5TmFtZUZvck9TIiwiaW5kZXhPZiIsInRvTG93ZXJDYXNlIiwiZW5kc1dpdGgiLCJiaW5hcnlMb2MiLCJiaW5hcnlMb2NzIiwicGF0aCIsInJlc29sdmUiLCJmb3JFYWNoIiwiZGlyIiwicHVzaCIsImxvYyIsImZzIiwiZXhpc3RzIiwiaXNOdWxsIiwiRXJyb3IiLCJ0cmltIiwiY21kIiwic3Rkb3V0IiwiZSIsImdldENvbm5lY3RlZERldmljZXMiLCJkZWJ1ZyIsImV4ZWN1dGFibGUiLCJkZWZhdWx0QXJncyIsImNvbmNhdCIsInN0YXJ0aW5nSW5kZXgiLCJzbGljZSIsImRldmljZXMiLCJsaW5lIiwic3BsaXQiLCJsaW5lSW5mbyIsInVkaWQiLCJzdGF0ZSIsImxlbmd0aCIsIm1lc3NhZ2UiLCJnZXREZXZpY2VzV2l0aFJldHJ5IiwidGltZW91dE1zIiwic3RhcnQiLCJEYXRlIiwibm93IiwiZ2V0RGV2aWNlcyIsInJlc3RhcnRBZGIiLCJzdXBwcmVzc0tpbGxTZXJ2ZXIiLCJraWxsU2VydmVyIiwiZXJyb3IiLCJhZGJQb3J0IiwicmVzZXRUZWxuZXRBdXRoVG9rZW4iLCJob21lRm9sZGVyUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJwbGF0Zm9ybSIsImRzdFBhdGgiLCJ3cml0ZUZpbGUiLCJhZGJFeGVjRW11IiwidmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQiLCJhZGJFeGVjIiwib3B0cyIsInRpbWVvdXQiLCJhZGJFeGVjVGltZW91dCIsImV4ZWNGdW5jIiwiQXJyYXkiLCJhcmdzIiwicmVwbGFjZSIsImVyclRleHQiLCJzdGRlcnIiLCJwcm90b2NvbEZhdWx0RXJyb3IiLCJ0ZXN0IiwiZGV2aWNlTm90Rm91bmRFcnJvciIsImRldmljZUNvbm5lY3RpbmdFcnJvciIsImNvZGUiLCJzaGVsbCIsInByaXZpbGVnZWQiLCJrZWVwUHJpdmlsZWdlZCIsInNob3VsZFJlc3RvcmVVc2VyIiwiaW5jbHVkZXMiLCJlcnIiLCJkaWRDb21tYW5kRmFpbCIsImlzQXJyYXkiLCJjcmVhdGVTdWJQcm9jZXNzIiwiSlNPTiIsInN0cmluZ2lmeSIsIlN1YlByb2Nlc3MiLCJnZXRBZGJQYXRoIiwiZ2V0QWRiU2VydmVyUG9ydCIsImdldEVtdWxhdG9yUG9ydCIsImVtdWxhdG9yUG9ydCIsInBvcnQiLCJnZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nIiwiZW1TdHIiLCJwb3J0UGF0dGVybiIsInBhcnNlSW50IiwiZXhlYyIsImdldENvbm5lY3RlZEVtdWxhdG9ycyIsImVtdWxhdG9ycyIsImRldmljZSIsInNldEVtdWxhdG9yUG9ydCIsImVtUG9ydCIsInNldERldmljZUlkIiwiZGV2aWNlSWQiLCJjdXJEZXZpY2VJZCIsImFyZ3NIYXNEZXZpY2UiLCJzcGxpY2UiLCJzZXREZXZpY2UiLCJkZXZpY2VPYmoiLCJnZXRSdW5uaW5nQVZEIiwiYXZkTmFtZSIsImVtdWxhdG9yIiwicnVubmluZ0FWRE5hbWUiLCJzZW5kVGVsbmV0Q29tbWFuZCIsImdldFJ1bm5pbmdBVkRXaXRoUmV0cnkiLCJydW5uaW5nQXZkIiwid2FpdE1zIiwiaW50ZXJ2YWxNcyIsImtpbGxBbGxFbXVsYXRvcnMiLCJraWxsRW11bGF0b3IiLCJ1dGlsIiwiaGFzVmFsdWUiLCJpc0VtdWxhdG9yQ29ubmVjdGVkIiwiaWduIiwibGF1bmNoQVZEIiwiYXZkQXJncyIsImxhbmd1YWdlIiwiY291bnRyeSIsImF2ZExhdW5jaFRpbWVvdXQiLCJhdmRSZWFkeVRpbWVvdXQiLCJyZXRyeVRpbWVzIiwiZW11bGF0b3JCaW5hcnlQYXRoIiwic3Vic3RyIiwiY2hlY2tBdmRFeGlzdCIsImxhdW5jaEFyZ3MiLCJpc1N0cmluZyIsInRvVXBwZXJDYXNlIiwibG9jYWxlIiwiaXNFbXB0eSIsInByb2MiLCJvbiIsImZpbHRlciIsIkJvb2xlYW4iLCJzaWduYWwiLCJ3YWl0Rm9yRW11bGF0b3JSZWFkeSIsImdldEFkYlZlcnNpb24iLCJhZGJWZXJzaW9uIiwicGFydHMiLCJ2ZXJzaW9uU3RyaW5nIiwidmVyc2lvbkZsb2F0IiwicGFyc2VGbG9hdCIsIm1ham9yIiwibWlub3IiLCJwYXRjaCIsInVuZGVmaW5lZCIsInJlc3VsdCIsInVua25vd25PcHRpb25FcnJvciIsInNka1ZlcnNpb24iLCJleGlzdGluZ3MiLCJ3YWl0Rm9yRGV2aWNlIiwiYXBwRGV2aWNlUmVhZHlUaW1lb3V0IiwicmV0cmllcyIsInBpbmciLCJyZWJvb3QiLCJCIiwiZGVsYXkiLCJzZXREZXZpY2VQcm9wZXJ0eSIsInN0YXJ0ZWQiLCJocnRpbWUiLCJnZXREZXZpY2VQcm9wZXJ0eSIsIm1zZyIsInJvb3QiLCJ1bnJvb3QiLCJpc1Jvb3QiLCJmaWxlRXhpc3RzIiwicmVtb3RlUGF0aCIsImZpbGVzIiwibHMiLCJsaW5lcyIsIm1hcCIsImwiLCJmaWxlU2l6ZSIsIm1hdGNoIiwiaXNOYU4iLCJpbnN0YWxsTWl0bUNlcnRpZmljYXRlIiwiY2VydCIsIm9wZW5Tc2wiLCJpc0J1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJ0bXBSb290IiwidGVtcERpciIsIm9wZW5EaXIiLCJzcmNDZXJ0IiwiY2VydEhhc2giLCJkc3RDZXJ0Q29udGVudCIsImRzdENlcnQiLCJyaW1yYWYiLCJpc01pdG1DZXJ0aWZpY2F0ZUluc3RhbGxlZCIsInRtcENlcnQiLCJwb3NpeCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFHQSxJQUFJQSxpQkFBaUIsR0FBRyxFQUF4QjtBQUVBLE1BQU1DLHdCQUF3QixHQUFHLEtBQWpDOztBQUNBLE1BQU1DLDBCQUEwQixHQUFHLEVBQW5DO0FBRUEsTUFBTUMscUJBQXFCLEdBQUcsc0JBQTlCO0FBQ0EsTUFBTUMsMkJBQTJCLEdBQUcsSUFBSUMsTUFBSixDQUFXLGdDQUFYLEVBQTZDLEdBQTdDLENBQXBDO0FBQ0EsTUFBTUMsNkJBQTZCLEdBQUcsSUFBSUQsTUFBSixDQUFZLGlDQUFaLEVBQThDLEdBQTlDLENBQXRDO0FBQ0EsTUFBTUUsOEJBQThCLEdBQUcsSUFBSUYsTUFBSixDQUFXLGdDQUFYLEVBQTZDLEdBQTdDLENBQXZDO0FBRUEsTUFBTUcsVUFBVSxHQUFHLDhCQUFuQjtBQVFBUixpQkFBaUIsQ0FBQ1MsZ0JBQWxCLEdBQXFDQyxnQkFBRUMsT0FBRixDQUFVLGdCQUFnQkMsVUFBaEIsRUFBNEI7QUFDekVDLGtCQUFJQyxJQUFKLENBQVUsb0JBQW1CRixVQUFXLGFBQXhDOztBQUNBLE1BQUksS0FBS0csT0FBVCxFQUFrQjtBQUNoQixXQUFPLE1BQU0sS0FBS0Msb0JBQUwsQ0FBMEJKLFVBQTFCLENBQWI7QUFDRDs7QUFDREMsa0JBQUlJLElBQUosQ0FBVSxzRUFBRCxHQUNDLGtFQURELEdBRUMseUNBQXdDTCxVQUFXLEdBRjdEOztBQUdBLFNBQU8sTUFBTSxLQUFLTSxpQkFBTCxDQUF1Qk4sVUFBdkIsQ0FBYjtBQUNELENBVG9DLENBQXJDO0FBa0JBWixpQkFBaUIsQ0FBQ21CLGVBQWxCLEdBQW9DVCxnQkFBRUMsT0FBRixDQUFVLFlBQVk7QUFDeEQsU0FBT1Msc0JBQU9DLFNBQVAsS0FBcUIsT0FBckIs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TyxHQUFHNUwsY0FBS0MsT0FBTCxDQUFha0wsT0FBYixFQUFzQixZQUF0QixDQUFoQjs7QUFDQSxVQUFNN0ssa0JBQUd3QyxTQUFILENBQWE4SSxPQUFiLEVBQXNCZCxJQUF0QixDQUFOO0FBQ0EsVUFBTTtBQUFDbEssTUFBQUE7QUFBRCxRQUFXLE1BQU0sd0JBQUttSyxPQUFMLEVBQWMsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixPQUFuQixFQUE0QixLQUE1QixFQUFtQ2EsT0FBbkMsQ0FBZCxDQUF2QjtBQUNBTCxJQUFBQSxRQUFRLEdBQUczSyxNQUFNLENBQUNGLElBQVAsRUFBWDtBQUNELEdBTEQsQ0FLRSxPQUFPMkQsR0FBUCxFQUFZO0FBQ1osVUFBTSxJQUFJNUQsS0FBSixDQUFXLHdDQUFELEdBQ0MsMERBREQsR0FFQyxtQkFBa0I0RCxHQUFHLENBQUN6QyxPQUFRLEVBRnpDLENBQU47QUFHRCxHQVRELFNBU1U7QUFDUixVQUFNdEIsa0JBQUdvTCxNQUFILENBQVVQLE9BQVYsQ0FBTjtBQUNEOztBQUNELFFBQU10SSxPQUFPLEdBQUc3QyxjQUFLNkwsS0FBTCxDQUFXNUwsT0FBWCxDQUFtQnJCLFVBQW5CLEVBQWdDLEdBQUUyTSxRQUFTLElBQTNDLENBQWhCOztBQUNBdE0sa0JBQUk4QixLQUFKLENBQVcsd0RBQXVEOEIsT0FBUSxHQUExRTs7QUFDQSxTQUFPLE1BQU0sS0FBS3NILFVBQUwsQ0FBZ0J0SCxPQUFoQixDQUFiO0FBQ0QsQ0F4QkQ7O2VBMEJlekUsaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyLmpzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHN5c3RlbSwgZnMsIHV0aWwsIHRlbXBEaXIgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBnZXRTZGtUb29sc1ZlcnNpb24sIGdldEJ1aWxkVG9vbHNEaXJzLCBnZXRPcGVuU3NsRm9yT3MgfSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IGV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgc2xlZXAsIHJldHJ5LCByZXRyeUludGVydmFsLCB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHF1b3RlIH0gZnJvbSAnc2hlbGwtcXVvdGUnO1xuXG5cbmxldCBzeXN0ZW1DYWxsTWV0aG9kcyA9IHt9O1xuXG5jb25zdCBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQgPSAyMDAwMDsgLy8gaW4gbWlsbGlzZWNvbmRzXG5jb25zdCBERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyA9IDkwO1xuXG5jb25zdCBMSU5LRVJfV0FSTklOR19SRUdFWFAgPSAvXldBUk5JTkc6IGxpbmtlci4rJC9tO1xuY29uc3QgUFJPVE9DT0xfRkFVTFRfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgncHJvdG9jb2wgZmF1bHQgXFxcXChubyBzdGF0dXNcXFxcKScsICdpJyk7XG5jb25zdCBERVZJQ0VfTk9UX0ZPVU5EX0VSUk9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoYGVycm9yOiBkZXZpY2UgKCcuKycgKT9ub3QgZm91bmRgLCAnaScpO1xuY29uc3QgREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgnZXJyb3I6IGRldmljZSBzdGlsbCBjb25uZWN0aW5nJywgJ2knKTtcblxuY29uc3QgQ0VSVFNfUk9PVCA9ICcvc3lzdGVtL2V0Yy9zZWN1cml0eS9jYWNlcnRzJztcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5IGluY2x1ZGluZyBjdXJyZW50IFNESyByb290LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRTZGtCaW5hcnlQYXRoID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIChiaW5hcnlOYW1lKSB7XG4gIGxvZy5pbmZvKGBDaGVja2luZyB3aGV0aGVyICR7YmluYXJ5TmFtZX0gaXMgcHJlc2VudGApO1xuICBpZiAodGhpcy5zZGtSb290KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmluYXJ5RnJvbVNka1Jvb3QoYmluYXJ5TmFtZSk7XG4gIH1cbiAgbG9nLndhcm4oYFRoZSBBTkRST0lEX0hPTUUgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldCB0byB0aGUgQW5kcm9pZCBTREsgYCArXG4gICAgICAgICAgIGByb290IGRpcmVjdG9yeSBwYXRoLiBBTkRST0lEX0hPTUUgaXMgcmVxdWlyZWQgZm9yIGNvbXBhdGliaWxpdHkgYCArXG4gICAgICAgICAgIGB3aXRoIFNESyAyMysuIENoZWNraW5nIGFsb25nIFBBVEggZm9yICR7YmluYXJ5TmFtZX0uYCk7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldEJpbmFyeUZyb21QYXRoKGJpbmFyeU5hbWUpO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIG5hbWUgb2YgdGhlIHRvb2wsXG4gKiB3aGljaCBwcmludHMgZnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBjb21tYW5kIHNob3J0Y3V0LlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtIHRoaXMgaXNcbiAqICAgICAgICAgICAgICAgICAgc3VwcG9zZWQgdG8gYmUgZWl0aGVyICd3aGljaCcgb3IgJ3doZXJlJy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29tbWFuZEZvck9TID0gXy5tZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHN5c3RlbS5pc1dpbmRvd3MoKSA/ICd3aGVyZScgOiAnd2hpY2gnO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBiaW5hcnkgbmFtZSBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIHNpbXBsZSBiaW5hcnkgbmFtZSwgZm9yIGV4YW1wbGUgJ2FuZHJvaWQnLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgYmluYXJ5IG5hbWUgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtLFxuICogICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgJ2FuZHJvaWQuYmF0JyBvbiBXaW5kb3dzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlOYW1lRm9yT1MgPSBfLm1lbW9pemUoZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgaWYgKCFzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICByZXR1cm4gYmluYXJ5TmFtZTtcbiAgfVxuXG4gIGlmIChbJ2FuZHJvaWQnLCAnYXBrc2lnbmVyJywgJ2Fwa2FuYWx5emVyJ10uaW5kZXhPZihiaW5hcnlOYW1lKSA+PSAwICYmXG4gICAgICAhYmluYXJ5TmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuYmF0JykpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uYmF0YDtcbiAgfVxuICBpZiAoIWJpbmFyeU5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmV4ZScpKSB7XG4gICAgcmV0dXJuIGAke2JpbmFyeU5hbWV9LmV4ZWA7XG4gIH1cbiAgcmV0dXJuIGJpbmFyeU5hbWU7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFNpbXBsZSBuYW1lIG9mIGEgYmluYXJ5IGZpbGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LiBUaGUgbWV0aG9kIHRyaWVzXG4gKiAgICAgICAgICAgICAgICAgIHRvIGVudW1lcmF0ZSBhbGwgdGhlIGtub3duIGxvY2F0aW9ucyB3aGVyZSB0aGUgYmluYXJ5XG4gKiAgICAgICAgICAgICAgICAgIG1pZ2h0IGJlIGxvY2F0ZWQgYW5kIHN0b3BzIHRoZSBzZWFyY2ggYXMgc29vbiBhcyB0aGUgZmlyc3RcbiAqICAgICAgICAgICAgICAgICAgbWF0Y2ggaXMgZm91bmQgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBiaW5hcnkgd2l0aCBnaXZlbiBuYW1lIGlzIG5vdCBwcmVzZW50IGF0IGFueVxuICogICAgICAgICAgICAgICAgIG9mIGtub3duIGxvY2F0aW9ucyBvciBBbmRyb2lkIFNESyBpcyBub3QgaW5zdGFsbGVkIG9uIHRoZVxuICogICAgICAgICAgICAgICAgIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tU2RrUm9vdCA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBsZXQgYmluYXJ5TG9jID0gbnVsbDtcbiAgYmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICBsZXQgYmluYXJ5TG9jcyA9IFtcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcInBsYXRmb3JtLXRvb2xzXCIsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsIFwiZW11bGF0b3JcIiwgYmluYXJ5TmFtZSksXG4gICAgcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJ0b29sc1wiLCBiaW5hcnlOYW1lKSxcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcInRvb2xzXCIsIFwiYmluXCIsIGJpbmFyeU5hbWUpXG4gIF07XG4gIC8vIGdldCBzdWJwYXRocyBmb3IgY3VycmVudGx5IGluc3RhbGxlZCBidWlsZCB0b29sIGRpcmVjdG9yaWVzXG4gIF8uZm9yRWFjaChhd2FpdCBnZXRCdWlsZFRvb2xzRGlycyh0aGlzLnNka1Jvb3QpLFxuICAgICAgICAgICAgKGRpcikgPT4gYmluYXJ5TG9jcy5wdXNoKHBhdGgucmVzb2x2ZShkaXIsIGJpbmFyeU5hbWUpKSk7XG4gIGZvciAobGV0IGxvYyBvZiBiaW5hcnlMb2NzKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhsb2MpKSB7XG4gICAgICBiaW5hcnlMb2MgPSBsb2M7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKF8uaXNOdWxsKGJpbmFyeUxvYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7YmluYXJ5TmFtZX0gaW4gJHtiaW5hcnlMb2NzfS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBEbyB5b3UgaGF2ZSB0aGUgQW5kcm9pZCBTREsgaW5zdGFsbGVkIGF0ICcke3RoaXMuc2RrUm9vdH0nP2ApO1xuICB9XG4gIGJpbmFyeUxvYyA9IGJpbmFyeUxvYy50cmltKCk7XG4gIGxvZy5pbmZvKGBVc2luZyAke2JpbmFyeU5hbWV9IGZyb20gJHtiaW5hcnlMb2N9YCk7XG4gIHJldHVybiBiaW5hcnlMb2M7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gYSBiaW5hcnkgZmlsZSB1c2luZyB0aGUgc3RhbmRhcmQgc3lzdGVtIGxvb2t1cCB0b29sLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGJpbmFyeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBiaW5hcnkgcmVjZWl2ZWQgZnJvbSAnd2hpY2gnLyd3aGVyZSdcbiAqICAgICAgICAgICAgICAgICAgb3V0cHV0LlxuICogQHRocm93cyB7RXJyb3J9IElmIGxvb2t1cCB0b29sIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeUZyb21QYXRoID0gYXN5bmMgZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgbGV0IGJpbmFyeUxvYyA9IG51bGw7XG4gIGxldCBjbWQgPSB0aGlzLmdldENvbW1hbmRGb3JPUygpO1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoY21kLCBbYmluYXJ5TmFtZV0pO1xuICAgIGxvZy5pbmZvKGBVc2luZyAke2JpbmFyeU5hbWV9IGZyb20gJHtzdGRvdXR9YCk7XG4gICAgLy8gVE9ETyB3cml0ZSBhIHRlc3QgZm9yIGJpbmFyaWVzIHdpdGggc3BhY2VzLlxuICAgIGJpbmFyeUxvYyA9IHN0ZG91dC50cmltKCk7XG4gICAgcmV0dXJuIGJpbmFyeUxvYztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgJHtiaW5hcnlOYW1lfSBQbGVhc2Ugc2V0IHRoZSBBTkRST0lEX0hPTUUgYCArXG4gICAgICAgICAgICAgIGBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aXRoIHRoZSBBbmRyb2lkIFNESyByb290IGRpcmVjdG9yeSBwYXRoLmApO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIHVkaWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBDdXJyZW50IGRldmljZSBzdGF0ZSwgYXMgaXQgaXMgdmlzaWJsZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FkYiBkZXZpY2VzIC1sXyBvdXRwdXQuXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBkZXZpY2VzIHZpc2libGUgdG8gYWRiLlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBkZXZpY2VzIG9yIGFuIGVtcHR5IGxpc3QgaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBubyBkZXZpY2VzIGFyZSBjb25uZWN0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxpc3RpbmcgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29ubmVjdGVkRGV2aWNlcyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKFwiR2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcy4uLlwiKTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuY29uY2F0KFsnZGV2aWNlcyddKSk7XG4gICAgLy8gZXhwZWN0aW5nIGFkYiBkZXZpY2VzIHRvIHJldHVybiBvdXRwdXQgYXNcbiAgICAvLyBMaXN0IG9mIGRldmljZXMgYXR0YWNoZWRcbiAgICAvLyBlbXVsYXRvci01NTU0XHRkZXZpY2VcbiAgICBsZXQgc3RhcnRpbmdJbmRleCA9IHN0ZG91dC5pbmRleE9mKFwiTGlzdCBvZiBkZXZpY2VzXCIpO1xuICAgIGlmIChzdGFydGluZ0luZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG91dHB1dCB3aGlsZSB0cnlpbmcgdG8gZ2V0IGRldmljZXMuIG91dHB1dCB3YXM6ICR7c3Rkb3V0fWApO1xuICAgIH1cbiAgICAvLyBzbGljaW5nIG91cHV0IHdlIGNhcmUgYWJvdXQuXG4gICAgc3Rkb3V0ID0gc3Rkb3V0LnNsaWNlKHN0YXJ0aW5nSW5kZXgpO1xuICAgIGxldCBkZXZpY2VzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzdGRvdXQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGlmIChsaW5lLnRyaW0oKSAhPT0gXCJcIiAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZihcIkxpc3Qgb2YgZGV2aWNlc1wiKSA9PT0gLTEgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoXCJhZGIgc2VydmVyXCIpID09PSAtMSAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZihcIiogZGFlbW9uXCIpID09PSAtMSAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZihcIm9mZmxpbmVcIikgPT09IC0xKSB7XG4gICAgICAgIGxldCBsaW5lSW5mbyA9IGxpbmUuc3BsaXQoXCJcXHRcIik7XG4gICAgICAgIC8vIHN0YXRlIGlzIGVpdGhlciBcImRldmljZVwiIG9yIFwib2ZmbGluZVwiLCBhZmFpY3RcbiAgICAgICAgZGV2aWNlcy5wdXNoKHt1ZGlkOiBsaW5lSW5mb1swXSwgc3RhdGU6IGxpbmVJbmZvWzFdfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtkZXZpY2VzLmxlbmd0aH0gZGV2aWNlKHMpIGNvbm5lY3RlZGApO1xuICAgIHJldHVybiBkZXZpY2VzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBnZXR0aW5nIGNvbm5lY3RlZCBkZXZpY2VzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZGV2aWNlcyB2aXNpYmxlIHRvIGFkYiB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZ2V0IGF0IGxlYXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIGxpc3QgaXRlbS5cbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBjb25uZWN0ZWQgZGV2aWNlcyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXREZXZpY2VzV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gKHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gIGxvZy5kZWJ1ZyhcIlRyeWluZyB0byBmaW5kIGEgY29ubmVjdGVkIGFuZHJvaWQgZGV2aWNlXCIpO1xuICBsZXQgZ2V0RGV2aWNlcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoKERhdGUubm93KCkgLSBzdGFydCkgPiB0aW1lb3V0TXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGVkIEFuZHJvaWQgZGV2aWNlLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICBpZiAoZGV2aWNlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhcIkNvdWxkIG5vdCBmaW5kIGRldmljZXMsIHJlc3RhcnRpbmcgYWRiIHNlcnZlci4uLlwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAgIC8vIGNvb2wgZG93blxuICAgICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmRlYnVnKFwiQ291bGQgbm90IGZpbmQgZGV2aWNlcywgcmVzdGFydGluZyBhZGIgc2VydmVyLi4uXCIpO1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAvLyBjb29sIGRvd25cbiAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGF3YWl0IGdldERldmljZXMoKTtcbn07XG5cbi8qKlxuICogUmVzdGFydCBhZGIgc2VydmVyLCB1bmxlc3MgX3RoaXMuc3VwcHJlc3NLaWxsU2VydmVyXyBwcm9wZXJ0eSBpcyB0cnVlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZXN0YXJ0QWRiID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdXBwcmVzc0tpbGxTZXJ2ZXIpIHtcbiAgICBsb2cuZGVidWcoYE5vdCByZXN0YXJ0aW5nIGFiZCBzaW5jZSAnc3VwcHJlc3NLaWxsU2VydmVyJyBpcyBvbmApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZygnUmVzdGFydGluZyBhZGInKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmtpbGxTZXJ2ZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvcihcIkVycm9yIGtpbGxpbmcgQURCIHNlcnZlciwgZ29pbmcgdG8gc2VlIGlmIGl0J3Mgb25saW5lIGFueXdheVwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBLaWxsIGFkYiBzZXJ2ZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxTZXJ2ZXIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhgS2lsbGluZyBhZGIgc2VydmVyIG9uIHBvcnQgJHt0aGlzLmFkYlBvcnR9YCk7XG4gIGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsuLi50aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MsICdraWxsLXNlcnZlciddKTtcbn07XG5cbi8qKlxuICogUmVzZXQgVGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3Rvb2xzLmFuZHJvaWQuY29tL3JlY2VudC9lbXVsYXRvcjI1MTZyZWxlYXNlbm90ZXN9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IElmIHRva2VuIHJlc2V0IHdhcyBzdWNjZXNzZnVsLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZXNldFRlbG5ldEF1dGhUb2tlbiA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiAoKSB7XG4gIC8vIFRoZSBtZXRob2RzIGlzIHVzZWQgdG8gcmVtb3ZlIHRlbG5ldCBhdXRoIHRva2VuXG4gIC8vXG4gIGNvbnN0IGhvbWVGb2xkZXJQYXRoID0gcHJvY2Vzcy5lbnZbKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpID8gJ1VTRVJQUk9GSUxFJyA6ICdIT01FJ107XG4gIGlmICghaG9tZUZvbGRlclBhdGgpIHtcbiAgICBsb2cud2FybihgQ2Fubm90IGZpbmQgdGhlIHBhdGggdG8gdXNlciBob21lIGZvbGRlci4gSWdub3JpbmcgcmVzZXR0aW5nIG9mIGVtdWxhdG9yJ3MgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUoaG9tZUZvbGRlclBhdGgsICcuZW11bGF0b3JfY29uc29sZV9hdXRoX3Rva2VuJyk7XG4gIGxvZy5kZWJ1ZyhgT3ZlcnJpZGluZyAke2RzdFBhdGh9IHdpdGggYW4gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHRlbG5ldCBhdXRoZW50aWNhdGlvbiBmb3IgZW11bGF0b3IgY29tbWFuZHNgKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0UGF0aCwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLndhcm4oYEVycm9yICR7ZS5tZXNzYWdlfSB3aGlsZSByZXNldHRpbmcgdGhlIGNvbnRlbnQgb2YgJHtkc3RQYXRofS4gSWdub3JpbmcgcmVzZXR0aW5nIG9mIGVtdWxhdG9yJ3MgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSk7XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gZW11bGF0b3IgY29tbWFuZCB1c2luZyBfYWRiIGVtdV8gdG9vbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVycy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlY0VtdSA9IGFzeW5jIGZ1bmN0aW9uIChjbWQpIHtcbiAgYXdhaXQgdGhpcy52ZXJpZnlFbXVsYXRvckNvbm5lY3RlZCgpO1xuICBhd2FpdCB0aGlzLnJlc2V0VGVsbmV0QXV0aFRva2VuKCk7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2VtdScsIC4uLmNtZF0pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBhZGIgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgb3IgYSBzaW5nbGUgc3RyaW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlYyA9IGFzeW5jIGZ1bmN0aW9uIChjbWQsIG9wdHMgPSB7fSkge1xuICBpZiAoIWNtZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHBhc3MgaW4gYSBjb21tYW5kIHRvIGFkYkV4ZWMoKVwiKTtcbiAgfVxuICAvLyBzZXR0aW5nIGRlZmF1bHQgdGltZW91dCBmb3IgZWFjaCBjb21tYW5kIHRvIHByZXZlbnQgaW5maW5pdGUgd2FpdC5cbiAgb3B0cy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IHRoaXMuYWRiRXhlY1RpbWVvdXQgfHwgREVGQVVMVF9BREJfRVhFQ19USU1FT1VUO1xuXG4gIGxldCBleGVjRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCEoY21kIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIGNtZCA9IFtjbWRdO1xuICAgICAgfVxuICAgICAgbGV0IGFyZ3MgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuY29uY2F0KGNtZCk7XG4gICAgICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7dGhpcy5leGVjdXRhYmxlLnBhdGh9ICR7cXVvdGUoYXJncyl9J2ApO1xuICAgICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgYXJncywgb3B0cyk7XG4gICAgICAvLyBzb21ldGltZXMgQURCIHByaW50cyBvdXQgd2VpcmQgc3Rkb3V0IHdhcm5pbmdzIHRoYXQgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gaW5jbHVkZSBpbiBhbnkgb2YgdGhlIHJlc3BvbnNlIGRhdGEsIHNvIGxldCdzIHN0cmlwIGl0IG91dFxuICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnJlcGxhY2UoTElOS0VSX1dBUk5JTkdfUkVHRVhQLCAnJykudHJpbSgpO1xuICAgICAgcmV0dXJuIHN0ZG91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnJUZXh0ID0gYCR7ZS5tZXNzYWdlfSwgJHtlLnN0ZG91dH0sICR7ZS5zdGRlcnJ9YDtcbiAgICAgIGNvbnN0IHByb3RvY29sRmF1bHRFcnJvciA9IFBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUC50ZXN0KGVyclRleHQpO1xuICAgICAgY29uc3QgZGV2aWNlTm90Rm91bmRFcnJvciA9IERFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQLnRlc3QoZXJyVGV4dCk7XG4gICAgICBjb25zdCBkZXZpY2VDb25uZWN0aW5nRXJyb3IgPSBERVZJQ0VfQ09OTkVDVElOR19FUlJPUl9SRUdFWFAudGVzdChlcnJUZXh0KTtcbiAgICAgIGlmIChwcm90b2NvbEZhdWx0RXJyb3IgfHwgZGV2aWNlTm90Rm91bmRFcnJvciB8fCBkZXZpY2VDb25uZWN0aW5nRXJyb3IpIHtcbiAgICAgICAgbG9nLmluZm8oYEVycm9yIHNlbmRpbmcgY29tbWFuZCwgcmVjb25uZWN0aW5nIGRldmljZSBhbmQgcmV0cnlpbmc6ICR7Y21kfWApO1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgYXdhaXQgdGhpcy5nZXREZXZpY2VzV2l0aFJldHJ5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLmNvZGUgPT09IDAgJiYgZS5zdGRvdXQpIHtcbiAgICAgICAgbGV0IHN0ZG91dCA9IGUuc3Rkb3V0O1xuICAgICAgICBzdGRvdXQgPSBzdGRvdXQucmVwbGFjZShMSU5LRVJfV0FSTklOR19SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICAgIHJldHVybiBzdGRvdXQ7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZXhlY3V0aW5nIGFkYkV4ZWMuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgQ29kZTogJyR7ZS5jb2RlfSdgKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGF3YWl0IHJldHJ5KDIsIGV4ZWNGdW5jKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2hlbGxFeGVjT3B0aW9uc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gcHJpdmlsZWdlZCBbZmFsc3ldIC0gV2hldGhlciB0byBydW4gdGhlIGdpdmVuIGNvbW1hbmQgYXMgcm9vdC5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGtlZXBQcml2aWxlZ2VkIFtmYWxzeV0gLSBXaGV0aGVyIHRvIGtlZXAgcm9vdCBtb2RlIGFmdGVyIGNvbW1hbmQgZXhlY3V0aW9uIGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBBbGwgb3RoZXIgcHJvcGVydGllcyBhcmUgdGhlIHNhbWUgYXMgZm9yIGBleGVjYCBjYWxsIGZyb20ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS10ZWVuX3Byb2Nlc3N9XG4gKiBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGNvbW1hbmQgdXNpbmcgX2FkYiBzaGVsbF8gcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fHN0cmluZ30gY21kIC0gVGhlIGFycmF5IG9mIHJlc3QgY29tbWFuZCBsaW5lIHBhcmFtZXRlcnMgb3IgYSBzaW5nbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgcGFyYW1ldGVyLlxuICogQHBhcmFtIHs/U2hlbGxFeGVjT3B0aW9uc30gb3B0cyBbe31dIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQ29tbWFuZCdzIHN0ZG91dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29tbWFuZCByZXR1cm5lZCBub24temVybyBleGl0IGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNoZWxsID0gYXN5bmMgZnVuY3Rpb24gKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBwcml2aWxlZ2VkLFxuICAgIGtlZXBQcml2aWxlZ2VkLFxuICB9ID0gb3B0cztcbiAgbGV0IHNob3VsZFJlc3RvcmVVc2VyID0gZmFsc2U7XG4gIGlmIChwcml2aWxlZ2VkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNob3VsZFJlc3RvcmVVc2VyID0gIShhd2FpdCB0aGlzLmFkYkV4ZWMoWydyb290J10sIG9wdHMpKS5pbmNsdWRlcygnYWxyZWFkeSBydW5uaW5nIGFzIHJvb3QnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ2FkYmQgY2Fubm90IHJ1biBhcyByb290JykpIHtcbiAgICAgICAgLy8gRG8gbm90IHNob3cgdGhlIHdhcm5pbmcgZm9yIHJlYWwgZGV2aWNlcywgd2hlcmUgcm9vdCBpcyBsb2NrZWRcbiAgICAgICAgbG9nLndhcm4oYENhbm5vdCBydW4gYWRiZCBhcyByb290LiBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGRpZENvbW1hbmRGYWlsID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYkV4ZWMoXy5pc0FycmF5KGNtZCkgPyBbJ3NoZWxsJywgLi4uY21kXSA6IFsnc2hlbGwnLCBjbWRdLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRpZENvbW1hbmRGYWlsID0gdHJ1ZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHByaXZpbGVnZWQgJiYgc2hvdWxkUmVzdG9yZVVzZXIgJiYgKCFrZWVwUHJpdmlsZWdlZCB8fCBkaWRDb21tYW5kRmFpbCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3Vucm9vdCddLCBvcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cud2FybihgQ2Fubm90IHJ1biBhZGJkIGFzIG5vbi1yb290LiBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmNyZWF0ZVN1YlByb2Nlc3MgPSBmdW5jdGlvbiAoYXJncyA9IFtdKSB7XG4gIC8vIGFkZCB0aGUgZGVmYXVsdCBhcmd1bWVudHNcbiAgYXJncyA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoYXJncyk7XG4gIGxvZy5kZWJ1ZyhgQ3JlYXRpbmcgQURCIHN1YnByb2Nlc3Mgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWApO1xuICByZXR1cm4gbmV3IFN1YlByb2Nlc3ModGhpcy5nZXRBZGJQYXRoKCksIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBhZGIgcG9ydC5cbiAqIEB0b2RvIGNhbiBwcm9iYWJseSBkZXByZWNhdGUgdGhpcyBub3cgdGhhdCB0aGUgbG9naWMgaXMganVzdCB0byByZWFkIHRoaXMuYWRiUG9ydFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBhZGIgcG9ydCBudW1iZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEFkYlNlcnZlclBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFkYlBvcnQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgZnJvbSBfYWRiIGRldml2ZXNfIG91dHB1dC5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgYXJlIG5vIGNvbm5lY3RlZCBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRFbXVsYXRvclBvcnQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhcIkdldHRpbmcgcnVubmluZyBlbXVsYXRvciBwb3J0XCIpO1xuICBpZiAodGhpcy5lbXVsYXRvclBvcnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbXVsYXRvclBvcnQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZXNbMF0udWRpZCk7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIHJldHVybiBwb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIHBvcnQgbm90IGZvdW5kYCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXZpY2VzIGNvbm5lY3RlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgYnkgcGFyc2luZyBlbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1TdHIgLSBFbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSBFaXRoZXIgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIF9mYWxzZV8gaWYgcG9ydCBudW1iZXIgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyA9IGZ1bmN0aW9uIChlbVN0cikge1xuICBsZXQgcG9ydFBhdHRlcm4gPSAvZW11bGF0b3ItKFxcZCspLztcbiAgaWYgKHBvcnRQYXR0ZXJuLnRlc3QoZW1TdHIpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHBvcnRQYXR0ZXJuLmV4ZWMoZW1TdHIpWzFdLCAxMCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBjdXJyZW50bHkgY29ubmVjdGVkIGVtdWxhdG9ycy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgY29ubmVjdGVkIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKFwiR2V0dGluZyBjb25uZWN0ZWQgZW11bGF0b3JzXCIpO1xuICB0cnkge1xuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgbGV0IGVtdWxhdG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGRldmljZSBvZiBkZXZpY2VzKSB7XG4gICAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2UudWRpZCk7XG4gICAgICBpZiAocG9ydCkge1xuICAgICAgICBkZXZpY2UucG9ydCA9IHBvcnQ7XG4gICAgICAgIGVtdWxhdG9ycy5wdXNoKGRldmljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtlbXVsYXRvcnMubGVuZ3RofSBlbXVsYXRvcihzKSBjb25uZWN0ZWRgKTtcbiAgICByZXR1cm4gZW11bGF0b3JzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBfZW11bGF0b3JQb3J0XyBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZW1Qb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgdG8gYmUgc2V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXRFbXVsYXRvclBvcnQgPSBmdW5jdGlvbiAoZW1Qb3J0KSB7XG4gIHRoaXMuZW11bGF0b3JQb3J0ID0gZW1Qb3J0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGN1cnJlbnQgZGV2aWNlIChfdGhpcy5jdXJEZXZpY2VJZF8pLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAtIFRoZSBkZXZpY2UgaWRlbnRpZmllci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RGV2aWNlSWQgPSBmdW5jdGlvbiAoZGV2aWNlSWQpIHtcbiAgbG9nLmRlYnVnKGBTZXR0aW5nIGRldmljZSBpZCB0byAke2RldmljZUlkfWApO1xuICB0aGlzLmN1ckRldmljZUlkID0gZGV2aWNlSWQ7XG4gIGxldCBhcmdzSGFzRGV2aWNlID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmluZGV4T2YoJy1zJyk7XG4gIGlmIChhcmdzSGFzRGV2aWNlICE9PSAtMSkge1xuICAgIC8vIHJlbW92ZSB0aGUgb2xkIGRldmljZSBpZCBmcm9tIHRoZSBhcmd1bWVudHNcbiAgICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3Muc3BsaWNlKGFyZ3NIYXNEZXZpY2UsIDIpO1xuICB9XG4gIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5wdXNoKCctcycsIGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB0aGUgY3VycmVudCBkZXZpY2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2VPYmogLSBUaGUgZGV2aWNlIG9iamVjdCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZSA9IGZ1bmN0aW9uIChkZXZpY2VPYmopIHtcbiAgbGV0IGRldmljZUlkID0gZGV2aWNlT2JqLnVkaWQ7XG4gIGxldCBlbVBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlSWQpO1xuICB0aGlzLnNldEVtdWxhdG9yUG9ydChlbVBvcnQpO1xuICB0aGlzLnNldERldmljZUlkKGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBlbXVsYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIEVtdWxhdG9yIG5hbWUuXG4gKiBAcmV0dXJuIHs/RGV2aWNlfSBDdXJyZW50bHkgcnVubmluZyBlbXVsYXRvciBvciBfbnVsbF8uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFJ1bm5pbmdBVkQgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSkge1xuICBsb2cuZGVidWcoYFRyeWluZyB0byBmaW5kICR7YXZkTmFtZX0gZW11bGF0b3JgKTtcbiAgdHJ5IHtcbiAgICBsZXQgZW11bGF0b3JzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWRFbXVsYXRvcnMoKTtcbiAgICBmb3IgKGxldCBlbXVsYXRvciBvZiBlbXVsYXRvcnMpIHtcbiAgICAgIHRoaXMuc2V0RW11bGF0b3JQb3J0KGVtdWxhdG9yLnBvcnQpO1xuICAgICAgbGV0IHJ1bm5pbmdBVkROYW1lID0gYXdhaXQgdGhpcy5zZW5kVGVsbmV0Q29tbWFuZChcImF2ZCBuYW1lXCIpO1xuICAgICAgaWYgKGF2ZE5hbWUgPT09IHJ1bm5pbmdBVkROYW1lKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgRm91bmQgZW11bGF0b3IgJHthdmROYW1lfSBpbiBwb3J0ICR7ZW11bGF0b3IucG9ydH1gKTtcbiAgICAgICAgdGhpcy5zZXREZXZpY2VJZChlbXVsYXRvci51ZGlkKTtcbiAgICAgICAgcmV0dXJuIGVtdWxhdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYEVtdWxhdG9yICR7YXZkTmFtZX0gbm90IHJ1bm5pbmdgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBBVkQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gRW11bGF0b3IgbmFtZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgWzIwMDAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHdhaXQgdW50aWwgYXQgbGVhc3Qgb25lIHJ1bm5pbmcgQVZEIG9iamVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgZGV0ZWN0ZWQuXG4gKiBAcmV0dXJuIHs/RGV2aWNlfSBDdXJyZW50bHkgcnVubmluZyBlbXVsYXRvciBvciBfbnVsbF8uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbm8gZGV2aWNlIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiB0aGUgdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lLCB0aW1lb3V0TXMgPSAyMDAwMCkge1xuICBsZXQgcnVubmluZ0F2ZDtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bm5pbmdBdmQgPSBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZS5yZXBsYWNlKCdAJywgJycpKTtcbiAgICAgICAgcmV0dXJuIHJ1bm5pbmdBdmQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhlLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICBpbnRlcnZhbE1zOiAxMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIEFWRCB3aXRoIHJldHJ5LiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbiAgcmV0dXJuIHJ1bm5pbmdBdmQ7XG59O1xuXG4vKipcbiAqIFNodXRkb3duIGFsbCBydW5uaW5nIGVtdWxhdG9ycyBieSBraWxsaW5nIHRoZWlyIHByb2Nlc3Nlcy5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYga2lsbGluZyB0b29sIHJldHVybmVkIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsQWxsRW11bGF0b3JzID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsZXQgY21kLCBhcmdzO1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgY21kID0gJ1RBU0tLSUxMJztcbiAgICBhcmdzID0gWydUQVNLS0lMTCcsICcvSU0nLCAnZW11bGF0b3IuZXhlJ107XG4gIH0gZWxzZSB7XG4gICAgY21kID0gJy91c3IvYmluL2tpbGxhbGwnO1xuICAgIGFyZ3MgPSBbJy1tJywgJ2VtdWxhdG9yKiddO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyhjbWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBraWxsaW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgZW11bGF0b3Igd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gTm8gZXJyb3JcbiAqIGlzIHRocm93biBpcyBnaXZlbiBhdmQgZG9lcyBub3QgZXhpc3QvaXMgbm90IHJ1bm5pbmcuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVtdWxhdG9yIHRvIGJlIGtpbGxlZC4gSWYgZW1wdHksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY3VycmVudCBlbXVsYXRvciB3aWxsIGJlIGtpbGxlZC5cbiAqIEBwYXJhbSB7P251bWJlcn0gdGltZW91dCBbNjAwMDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIHRocm93aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGV4Y2VwdGlvbiBhYm91dCB1bnN1Y2Nlc3NmdWwga2lsbGluZ1xuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBlbXVsYXRvciB3YXMga2lsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGEgZmFpbHVyZSBieSBraWxsaW5nIHRoZSBlbXVsYXRvclxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsRW11bGF0b3IgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSA9IG51bGwsIHRpbWVvdXQgPSA2MDAwMCkge1xuICBpZiAodXRpbC5oYXNWYWx1ZShhdmROYW1lKSkge1xuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhdmQgJyR7YXZkTmFtZX0nYCk7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUpO1xuICAgIGlmICghZGV2aWNlKSB7XG4gICAgICBsb2cuaW5mbyhgTm8gYXZkIHdpdGggbmFtZSAnJHthdmROYW1lfScgcnVubmluZy4gU2tpcHBpbmcga2lsbCBzdGVwLmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBraWxsaW5nIHRoZSBjdXJyZW50IGF2ZFxuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhdmQgd2l0aCBpZCAnJHt0aGlzLmN1ckRldmljZUlkfSdgKTtcbiAgICBpZiAoIWF3YWl0IHRoaXMuaXNFbXVsYXRvckNvbm5lY3RlZCgpKSB7XG4gICAgICBsb2cuZGVidWcoYEVtdWxhdG9yIHdpdGggaWQgJyR7dGhpcy5jdXJEZXZpY2VJZH0nIG5vdCBjb25uZWN0ZWQuIFNraXBwaW5nIGtpbGwgc3RlcGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAna2lsbCddKTtcbiAgbG9nLmRlYnVnKGBXYWl0aW5nIHVwIHRvICR7dGltZW91dH1tcyB1bnRpbCB0aGUgZW11bGF0b3IgJyR7YXZkTmFtZSA/IGF2ZE5hbWUgOiB0aGlzLmN1ckRldmljZUlkfScgaXMga2lsbGVkYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXRpbC5oYXNWYWx1ZShhdmROYW1lKVxuICAgICAgICAgID8gIWF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lKVxuICAgICAgICAgIDogIWF3YWl0IHRoaXMuaXNFbXVsYXRvckNvbm5lY3RlZCgpO1xuICAgICAgfSBjYXRjaCAoaWduKSB7fVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dCxcbiAgICAgIGludGVydmFsTXM6IDIwMDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBlbXVsYXRvciAnJHthdmROYW1lID8gYXZkTmFtZSA6IHRoaXMuY3VyRGV2aWNlSWR9JyBpcyBzdGlsbCBydW5uaW5nIGFmdGVyIGJlaW5nIGtpbGxlZCAke3RpbWVvdXR9bXMgYWdvYCk7XG4gIH1cbiAgbG9nLmluZm8oYFN1Y2Nlc3NmdWxseSBraWxsZWQgdGhlICcke2F2ZE5hbWUgPyBhdmROYW1lIDogdGhpcy5jdXJEZXZpY2VJZH0nIGVtdWxhdG9yYCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBTdGFydCBhbiBlbXVsYXRvciB3aXRoIGdpdmVuIHBhcmFtZXRlcnMgYW5kIHdhaXQgdW50aWwgaXQgaXMgZnVsbCBzdGFydGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgYW4gZXhpc3RpbmcgZW11bGF0b3IuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gYXZkQXJncyAtIEFkZGl0aW9uYWwgZW11bGF0b3IgY29tbWFuZCBsaW5lIGFyZ3VtZW50LlxuICogQHBhcmFtIHs/c3RyaW5nfSBsYW5ndWFnZSAtIEVtdWxhdG9yIHN5c3RlbSBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7P2NvdW50cnl9IGNvdW50cnkgLSBFbXVsYXRvciBzeXN0ZW0gY291bnRyeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhdmRMYXVuY2hUaW1lb3V0IFs2MDAwMF0gLSBFbXVsYXRvciBzdGFydHVwIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJldHJ5VGltZXMgWzFdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHN0YXJ0dXAgcmV0cmllcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW11bGF0b3IgZmFpbHMgdG8gc3RhcnQgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5sYXVuY2hBVkQgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSwgYXZkQXJncywgbGFuZ3VhZ2UsIGNvdW50cnksXG4gIGF2ZExhdW5jaFRpbWVvdXQgPSA2MDAwMCwgYXZkUmVhZHlUaW1lb3V0ID0gNjAwMDAsIHJldHJ5VGltZXMgPSAxKSB7XG4gIGxvZy5kZWJ1ZyhgTGF1bmNoaW5nIEVtdWxhdG9yIHdpdGggQVZEICR7YXZkTmFtZX0sIGxhdW5jaFRpbWVvdXQgYCArXG4gICAgICAgICAgICBgJHthdmRMYXVuY2hUaW1lb3V0fW1zIGFuZCByZWFkeVRpbWVvdXQgJHthdmRSZWFkeVRpbWVvdXR9bXNgKTtcbiAgbGV0IGVtdWxhdG9yQmluYXJ5UGF0aCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aChcImVtdWxhdG9yXCIpO1xuICBpZiAoYXZkTmFtZVswXSA9PT0gXCJAXCIpIHtcbiAgICBhdmROYW1lID0gYXZkTmFtZS5zdWJzdHIoMSk7XG4gIH1cbiAgYXdhaXQgdGhpcy5jaGVja0F2ZEV4aXN0KGF2ZE5hbWUpO1xuICBsZXQgbGF1bmNoQXJncyA9IFtcIi1hdmRcIiwgYXZkTmFtZV07XG4gIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSkge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBBbmRyb2lkIERldmljZSBMYW5ndWFnZSB0byAke2xhbmd1YWdlfWApO1xuICAgIGxhdW5jaEFyZ3MucHVzaChcIi1wcm9wXCIsIGBwZXJzaXN0LnN5cy5sYW5ndWFnZT0ke2xhbmd1YWdlLnRvTG93ZXJDYXNlKCl9YCk7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcoY291bnRyeSkpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgQ291bnRyeSB0byAke2NvdW50cnl9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKFwiLXByb3BcIiwgYHBlcnNpc3Quc3lzLmNvdW50cnk9JHtjb3VudHJ5LnRvVXBwZXJDYXNlKCl9YCk7XG4gIH1cbiAgbGV0IGxvY2FsZTtcbiAgaWYgKF8uaXNTdHJpbmcobGFuZ3VhZ2UpICYmIF8uaXNTdHJpbmcoY291bnRyeSkpIHtcbiAgICBsb2NhbGUgPSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpICsgXCItXCIgKyBjb3VudHJ5LnRvVXBwZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhsYW5ndWFnZSkpIHtcbiAgICBsb2NhbGUgPSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoY291bnRyeSkpIHtcbiAgICBsb2NhbGUgPSBjb3VudHJ5O1xuICB9XG4gIGlmIChfLmlzU3RyaW5nKGxvY2FsZSkpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgTG9jYWxlIHRvICR7bG9jYWxlfWApO1xuICAgIGxhdW5jaEFyZ3MucHVzaChcIi1wcm9wXCIsIGBwZXJzaXN0LnN5cy5sb2NhbGU9JHtsb2NhbGV9YCk7XG4gIH1cbiAgaWYgKCFfLmlzRW1wdHkoYXZkQXJncykpIHtcbiAgICBsYXVuY2hBcmdzLnB1c2goLi4uKF8uaXNBcnJheShhdmRBcmdzKSA/IGF2ZEFyZ3MgOiBhdmRBcmdzLnNwbGl0KCcgJykpKTtcbiAgfVxuICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7ZW11bGF0b3JCaW5hcnlQYXRofScgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGxhdW5jaEFyZ3MpfWApO1xuICBsZXQgcHJvYyA9IG5ldyBTdWJQcm9jZXNzKGVtdWxhdG9yQmluYXJ5UGF0aCwgbGF1bmNoQXJncyk7XG4gIGF3YWl0IHByb2Muc3RhcnQoMCk7XG4gIHByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2YgKHN0ZG91dCB8fCBzdGRlcnIgfHwgJycpLnNwbGl0KCdcXG4nKS5maWx0ZXIoQm9vbGVhbikpIHtcbiAgICAgIGxvZy5pbmZvKGBbQVZEIE9VVFBVVF0gJHtsaW5lfWApO1xuICAgIH1cbiAgfSk7XG4gIHByb2Mub24oJ2RpZScsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICBsb2cud2FybihgRW11bGF0b3IgYXZkICR7YXZkTmFtZX0gZXhpdGVkIHdpdGggY29kZSAke2NvZGV9JHtzaWduYWwgPyBgLCBzaWduYWwgJHtzaWduYWx9YCA6ICcnfWApO1xuICB9KTtcbiAgYXdhaXQgcmV0cnkocmV0cnlUaW1lcywgYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5KGF2ZE5hbWUsIGF2ZExhdW5jaFRpbWVvdXQpKTtcbiAgYXdhaXQgdGhpcy53YWl0Rm9yRW11bGF0b3JSZWFkeShhdmRSZWFkeVRpbWVvdXQpO1xuICByZXR1cm4gcHJvYztcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQURCVmVyc2lvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZlcnNpb25TdHJpbmcgLSBBREIgdmVyc2lvbiBhcyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IHZlcnNpb25GbG9hdCAtIFZlcnNpb24gbnVtYmVyIGFzIGZsb2F0IHZhbHVlICh1c2VmdWwgZm9yIGNvbXBhcmlzb24pLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1ham9yIC0gTWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWlub3IgLSBNaW5vciB2ZXJzaW9uIG51bWJlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXRjaCAtIFBhdGNoIHZlcnNpb24gbnVtYmVyLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSBhZGIgdmVyc2lvbi4gVGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBjYWNoZWQuXG4gKlxuICogQHJldHVybiB7QURCVmVyc2lvbn0gVGhlIGN1cnJlbnQgYWRiIHZlcnNpb24uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHBhcnNlIGFkYiB2ZXJzaW9uLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJWZXJzaW9uID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBsZXQgYWRiVmVyc2lvbiA9IChhd2FpdCB0aGlzLmFkYkV4ZWMoJ3ZlcnNpb24nKSlcbiAgICAgIC5yZXBsYWNlKC9BbmRyb2lkXFxzRGVidWdcXHNCcmlkZ2VcXHN2ZXJzaW9uXFxzKFtcXGQuXSopW1xcc1xcdy1dKi8sIFwiJDFcIik7XG4gICAgbGV0IHBhcnRzID0gYWRiVmVyc2lvbi5zcGxpdCgnLicpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uU3RyaW5nOiBhZGJWZXJzaW9uLFxuICAgICAgdmVyc2lvbkZsb2F0OiBwYXJzZUZsb2F0KGFkYlZlcnNpb24pLFxuICAgICAgbWFqb3I6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBtaW5vcjogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIHBhdGNoOiBwYXJ0c1syXSA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBhZGIgdmVyc2lvbi4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIENoZWNrIGlmIGdpdmVuIGVtdWxhdG9yIGV4aXN0cyBpbiB0aGUgbGlzdCBvZiBhdmFpbGFibGUgYXZkcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIFRoZSBuYW1lIG9mIGVtdWxhdG9yIHRvIHZlcmlmeSBmb3IgZXhpc3RlbmNlLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciB3aXRoIGdpdmVuIG5hbWUgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmNoZWNrQXZkRXhpc3QgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSkge1xuICBsZXQgY21kLCByZXN1bHQ7XG4gIHRyeSB7XG4gICAgY21kID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKCdlbXVsYXRvcicpO1xuICAgIHJlc3VsdCA9IGF3YWl0IGV4ZWMoY21kLCBbJy1saXN0LWF2ZHMnXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsZXQgdW5rbm93bk9wdGlvbkVycm9yID0gbmV3IFJlZ0V4cChcInVua25vd24gb3B0aW9uOiAtbGlzdC1hdmRzXCIsIFwiaVwiKS50ZXN0KGUuc3RkZXJyKTtcbiAgICBpZiAoIXVua25vd25PcHRpb25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBleGVjdXRpbmcgY2hlY2tBdmRFeGlzdC4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuXG4gICAgfVxuICAgIGNvbnN0IHNka1ZlcnNpb24gPSBhd2FpdCBnZXRTZGtUb29sc1ZlcnNpb24oKTtcbiAgICBsZXQgYmluYXJ5TmFtZSA9ICdhbmRyb2lkJztcbiAgICBpZiAoc2RrVmVyc2lvbikge1xuICAgICAgaWYgKHNka1ZlcnNpb24ubWFqb3IgPj0gMjUpIHtcbiAgICAgICAgYmluYXJ5TmFtZSA9ICdhdmRtYW5hZ2VyJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLndhcm4oYERlZmF1bHRpbmcgYmluYXJ5IG5hbWUgdG8gJyR7YmluYXJ5TmFtZX0nLCBiZWNhdXNlIFNESyB2ZXJzaW9uIGNhbm5vdCBiZSBwYXJzZWRgKTtcbiAgICB9XG4gICAgLy8gSWYgLWxpc3QtYXZkcyBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSwgdXNlIGFuZHJvaWQgY29tbWFuZCBhcyBhbiBhbHRlcm5hdGl2ZVxuICAgIGNtZCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aChiaW5hcnlOYW1lKTtcbiAgICByZXN1bHQgPSBhd2FpdCBleGVjKGNtZCwgWydsaXN0JywgJ2F2ZCcsICctYyddKTtcbiAgfVxuICBpZiAocmVzdWx0LnN0ZG91dC5pbmRleE9mKGF2ZE5hbWUpID09PSAtMSkge1xuICAgIGxldCBleGlzdGluZ3MgPSBgKCR7cmVzdWx0LnN0ZG91dC50cmltKCkucmVwbGFjZSgvW1xcbl0vZywgJyksICgnKX0pYDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEF2ZCAnJHthdmROYW1lfScgaXMgbm90IGF2YWlsYWJsZS4gcGxlYXNlIHNlbGVjdCB5b3VyIGF2ZCBuYW1lIGZyb20gb25lIG9mIHRoZXNlOiAnJHtleGlzdGluZ3N9J2ApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGVtdWxhdG9yIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciBpcyBub3QgcmVhZHkgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy53YWl0Rm9yRW11bGF0b3JSZWFkeSA9IGFzeW5jIGZ1bmN0aW9uICh0aW1lb3V0TXMgPSAyMDAwMCkge1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5zaGVsbChbJ2dldHByb3AnLCAnaW5pdC5zdmMuYm9vdGFuaW0nXSkpLmluY2x1ZGVzKCdzdG9wcGVkJykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZSBwYWNrYWdlIG1hbmFnZXIgc2VydmljZSBtaWdodCBzdGlsbCBiZWluZyBpbml0aWFsaXplZFxuICAgICAgICAvLyBvbiBzbG93IHN5c3RlbXMgZXZlbiBhZnRlciBlbXVsYXRvciBib290aW5nIGlzIGNvbXBsZXRlZC5cbiAgICAgICAgLy8gVGhlIHVzdWFsIG91dHB1dCBvZiBgcG0gZ2V0LWluc3RhbGwtbG9jYXRpb25gIGNvbW1hbmQgbG9va3MgbGlrZSBgMFthdXRvXWBcbiAgICAgICAgcmV0dXJuIC9cXGQrXFxbXFx3K1xcXS8udGVzdChhd2FpdCB0aGlzLnNoZWxsKFsncG0nLCAnZ2V0LWluc3RhbGwtbG9jYXRpb24nXSkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgV2FpdGluZyBmb3IgZW11bGF0b3Igc3RhcnR1cC4gSW50ZXJtZWRpYXRlIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICBpbnRlcnZhbE1zOiAzMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFbXVsYXRvciBpcyBub3QgcmVhZHkgd2l0aGluICR7dGltZW91dE1zfW1zYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFwcERldmljZVJlYWR5VGltZW91dCBbMzBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGV2aWNlIGlzIG5vdCByZWFkeSB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JEZXZpY2UgPSBhc3luYyBmdW5jdGlvbiAoYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gMzApIHtcbiAgdGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQgPSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQ7XG4gIGNvbnN0IHJldHJpZXMgPSAzO1xuICBjb25zdCB0aW1lb3V0ID0gcGFyc2VJbnQodGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQsIDEwKSAvIHJldHJpZXMgKiAxMDAwO1xuICBhd2FpdCByZXRyeShyZXRyaWVzLCBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYygnd2FpdC1mb3ItZGV2aWNlJywge3RpbWVvdXR9KTtcbiAgICAgIGF3YWl0IHRoaXMucGluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdhaXRpbmcgZm9yIHRoZSBkZXZpY2UgdG8gYmUgYXZhaWxhYmxlLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSdgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWJvb3QgdGhlIGN1cnJlbnQgZGV2aWNlIGFuZCB3YWl0IHVudGlsIGl0IGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cmllcyBbREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVNdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlYm9vdCByZXRyaWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgZmFpbGVkIHRvIHJlYm9vdCBhbmQgbnVtYmVyIG9mIHJldHJpZXMgaXMgZXhjZWVkZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlYm9vdCA9IGFzeW5jIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVMpIHtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0b3AnXSwge1xuICAgIHByaXZpbGVnZWQ6IHRydWUsXG4gIH0pO1xuICBhd2FpdCBCLmRlbGF5KDIwMDApOyAvLyBsZXQgdGhlIGVtdSBmaW5pc2ggc3RvcHBpbmc7XG4gIGF3YWl0IHRoaXMuc2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcsIDApO1xuICBhd2FpdCB0aGlzLnNoZWxsKFsnc3RhcnQnXSwge1xuICAgIHByaXZpbGVnZWQ6IHRydWUsXG4gIH0pO1xuICBjb25zdCBzdGFydGVkID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgYXdhaXQgcmV0cnlJbnRlcnZhbChyZXRyaWVzLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKChhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnKSkgPT09ICcxJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBzdGFjayB0cmFjZSwgc28gbm8gbG9nLmVycm9yQW5kVGhyb3dcbiAgICBjb25zdCBtc2cgPSBgUmVib290IGlzIG5vdCBjb21wbGV0ZWQgYWZ0ZXIgJHtwcm9jZXNzLmhydGltZShzdGFydGVkKVswXX1zYDtcbiAgICBsb2cuZGVidWcobXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN3aXRjaCBhZGIgc2VydmVyIHRvIHJvb3QgbW9kZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9mIHRoZSBzd2l0Y2ggd2FzIHN1Y2Nlc3NmdWwgb3IgZmFsc2VcbiAqICAgICAgICAgICAgICAgICAgIGlmIHRoZSBzd2l0Y2ggZmFpbGVkLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yb290ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsncm9vdCddKTtcblxuICAgIC8vIG9uIHJlYWwgZGV2aWNlcyBpbiBzb21lIHNpdHVhdGlvbnMgd2UgZ2V0IGFuIGVycm9yIGluIHRoZSBzdGRvdXRcbiAgICBpZiAoc3Rkb3V0ICYmIHN0ZG91dC5pbmRleE9mKCdhZGJkIGNhbm5vdCBydW4gYXMgcm9vdCcpICE9PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0ZG91dC50cmltKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvIHJvb3QgYWRiIGRhZW1vbjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byBub24tcm9vdCBtb2RlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb2YgdGhlIHN3aXRjaCB3YXMgc3VjY2Vzc2Z1bCBvciBmYWxzZVxuICogICAgICAgICAgICAgICAgICAgaWYgdGhlIHN3aXRjaCBmYWlsZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnVucm9vdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbJ3Vucm9vdCddKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYFVuYWJsZSB0byB1bnJvb3QgYWRiIGRhZW1vbjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCB1c2VyIGlzIHJvb3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB1c2VyIGlzIHJvb3RcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaWRlbnRpZnlpbmdcbiAqIHRoZSB1c2VyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pc1Jvb3QgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoYXdhaXQgdGhpcy5zaGVsbChbJ3dob2FtaSddKSkudHJpbSgpID09PSAncm9vdCc7XG59O1xuXG4vKipcbiAqIFZlcmlmeSB3aGV0aGVyIGEgcmVtb3RlIHBhdGggZXhpc3RzIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCB0byB2ZXJpZnkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBwYXRoIGV4aXN0cyBvbiB0aGUgZGV2aWNlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5maWxlRXhpc3RzID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgpIHtcbiAgbGV0IGZpbGVzID0gYXdhaXQgdGhpcy5scyhyZW1vdGVQYXRoKTtcbiAgcmV0dXJuIGZpbGVzLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb3V0cHV0IG9mIF9sc18gY29tbWFuZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggKHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgX2xzXyBjb21tYW5kKS5cbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IG9wdHMgW1tdXSAtIEFkZGl0aW9uYWwgX2xzXyBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59IFRoZSBfbHNfIG91dHB1dCBhcyBhbiBhcnJheSBvZiBzcGxpdCBsaW5lcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBvZiB0aGUgZ2l2ZW4gX3JlbW90ZVBhdGhfXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmxzID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgsIG9wdHMgPSBbXSkge1xuICB0cnkge1xuICAgIGxldCBhcmdzID0gWydscycsIC4uLm9wdHMsIHJlbW90ZVBhdGhdO1xuICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xuICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdChcIlxcblwiKTtcbiAgICByZXR1cm4gbGluZXMubWFwKChsKSA9PiBsLnRyaW0oKSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5maWx0ZXIoKGwpID0+IGwuaW5kZXhPZihcIk5vIHN1Y2ggZmlsZVwiKSA9PT0gLTEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScpID09PSAtMSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSBwYXJ0aWN1bGFyIGZpbGUgbG9jYXRlZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggdG8gdGhlIGZpbGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEZpbGUgc2l6ZSBpbiBieXRlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gZmlsZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZmlsZVNpemUgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCkge1xuICB0cnkge1xuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgdGhpcy5scyhyZW1vdGVQYXRoLCBbJy1sYSddKTtcbiAgICBpZiAoZmlsZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlbW90ZSBwYXRoIGlzIG5vdCBhIGZpbGVgKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20vci9mT3M0UDQvOFxuICAgIGNvbnN0IG1hdGNoID0gL1tyd3hzU3RUXFwtK117MTB9W1xcc1xcZF0qXFxzW15cXHNdK1xccytbXlxcc10rXFxzKyhcXGQrKS8uZXhlYyhmaWxlc1swXSk7XG4gICAgaWYgKCFtYXRjaCB8fCBfLmlzTmFOKHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBzaXplIGZyb20gbGlzdCBvdXRwdXQ6ICcke2ZpbGVzWzBdfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGdldCBmaWxlIHNpemUgZm9yICcke3JlbW90ZVBhdGh9JzogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnN0YWxscyB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgb24gYSByb290ZWQgcmVhbCBkZXZpY2Ugb3JcbiAqIGFuIGVtdWxhdG9yLiBUaGUgZW11bGF0b3IgbXVzdCBiZSBleGVjdXRlZCB3aXRoIGAtd3JpdGFibGUtc3lzdGVtYFxuICogY29tbWFuZCBsaW5lIG9wdGlvbiBhbmQgYWRiIGRhZW1vbiBzaG91bGQgYmUgcnVubmluZyBpbiByb290XG4gKiBtb2RlIGZvciB0aGlzIG1ldGhvZCB0byB3b3JrIHByb3Blcmx5LiBUaGUgbWV0aG9kIGFsc28gcmVxdWlyZXNcbiAqIG9wZW5zc2wgdG9vbCB0byBiZSBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbS5cbiAqIFJlYWQgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vaXNzdWVzLzEwOTY0XG4gKiBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoaXMgdG9waWNcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGNlcnQgLSBiYXNlNjQtZGVjb2RlZCBjb250ZW50IG9mIHRoZSBhY3R1YWwgY2VydGlmaWNhdGVcbiAqIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9yIGEgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgb3BlbnNzbCB0b29sIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbVxuICogb3IgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGluc3RhbGxpbmcgdGhlIGNlcnRpZmljYXRlXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmluc3RhbGxNaXRtQ2VydGlmaWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoY2VydCkge1xuICBjb25zdCBvcGVuU3NsID0gYXdhaXQgZ2V0T3BlblNzbEZvck9zKCk7XG5cbiAgaWYgKCFfLmlzQnVmZmVyKGNlcnQpKSB7XG4gICAgY2VydCA9IEJ1ZmZlci5mcm9tKGNlcnQsICdiYXNlNjQnKTtcbiAgfVxuXG4gIGNvbnN0IHRtcFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzcmNDZXJ0ID0gcGF0aC5yZXNvbHZlKHRtcFJvb3QsICdzb3VyY2UuY2VyJyk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHNyY0NlcnQsIGNlcnQpO1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1ub291dCcsICctaGFzaCcsICctaW4nLCBzcmNDZXJ0XSk7XG4gICAgY29uc3QgY2VydEhhc2ggPSBzdGRvdXQudHJpbSgpO1xuICAgIGxvZy5kZWJ1ZyhgR290IGNlcnRpZmljYXRlIGhhc2g6ICR7Y2VydEhhc2h9YCk7XG4gICAgbG9nLmRlYnVnKCdQcmVwYXJpbmcgY2VydGlmaWNhdGUgY29udGVudCcpO1xuICAgICh7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1pbicsIHNyY0NlcnRdLCB7aXNCdWZmZXI6IHRydWV9KSk7XG4gICAgbGV0IGRzdENlcnRDb250ZW50ID0gc3Rkb3V0O1xuICAgICh7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JyxcbiAgICAgICctaW4nLCBzcmNDZXJ0LFxuICAgICAgJy10ZXh0JyxcbiAgICAgICctZmluZ2VycHJpbnQnLFxuICAgICAgJy1ub291dCddLCB7aXNCdWZmZXI6IHRydWV9KSk7XG4gICAgZHN0Q2VydENvbnRlbnQgPSBCdWZmZXIuY29uY2F0KFtkc3RDZXJ0Q29udGVudCwgc3Rkb3V0XSk7XG4gICAgY29uc3QgZHN0Q2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCBgJHtjZXJ0SGFzaH0uMGApO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RDZXJ0LCBkc3RDZXJ0Q29udGVudCk7XG4gICAgbG9nLmRlYnVnKCdSZW1vdW50aW5nIC9zeXN0ZW0gaW4gcncgbW9kZScpO1xuICAgIC8vIFNvbWV0aW1lcyBlbXVsYXRvciByZWJvb3QgaXMgc3RpbGwgbm90IGZ1bGx5IGZpbmlzaGVkIG9uIHRoaXMgc3RhZ2UsIHNvIHJldHJ5XG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbCg1LCAyMDAwLCBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLmFkYkV4ZWMoWydyZW1vdW50J10pKTtcbiAgICBsb2cuZGVidWcoYFVwbG9hZGluZyB0aGUgZ2VuZXJhdGVkIGNlcnRpZmljYXRlIGZyb20gJyR7ZHN0Q2VydH0nIHRvICcke0NFUlRTX1JPT1R9J2ApO1xuICAgIGF3YWl0IHRoaXMucHVzaChkc3RDZXJ0LCBDRVJUU19ST09UKTtcbiAgICBsb2cuZGVidWcoJ1JlbW91bnRpbmcgL3N5c3RlbSB0byBjb25maXJtIGNoYW5nZXMnKTtcbiAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydyZW1vdW50J10pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpbmplY3QgdGhlIGN1c3RvbSBjZXJ0aWZpY2F0ZS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJcyB0aGUgY2VydGlmaWNhdGUgcHJvcGVybHkgZW5jb2RlZCBpbnRvIGJhc2U2NC1zdHJpbmc/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgRG8geW91IGhhdmUgcm9vdCBwZXJtaXNzaW9ucyBvbiB0aGUgZGV2aWNlPyBgICtcbiAgICAgICAgICAgICAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgfVxufTtcblxuLyoqXG4gKiBWZXJpZmllcyBpZiB0aGUgZ2l2ZW4gcm9vdCBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZCBvbiB0aGUgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gY2VydCAtIGJhc2U2NC1kZWNvZGVkIGNvbnRlbnQgb2YgdGhlIGFjdHVhbCBjZXJ0aWZpY2F0ZVxuICogcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgb3IgYSBidWZmZXJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBvcGVuc3NsIHRvb2wgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtXG4gKiBvciBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY2hlY2tpbmcgdGhlIGNlcnRpZmljYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgaXMgYWxyZWFkeSBpbnN0YWxsZWRcbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaXNNaXRtQ2VydGlmaWNhdGVJbnN0YWxsZWQgPSBhc3luYyBmdW5jdGlvbiAoY2VydCkge1xuICBjb25zdCBvcGVuU3NsID0gYXdhaXQgZ2V0T3BlblNzbEZvck9zKCk7XG5cbiAgaWYgKCFfLmlzQnVmZmVyKGNlcnQpKSB7XG4gICAgY2VydCA9IEJ1ZmZlci5mcm9tKGNlcnQsICdiYXNlNjQnKTtcbiAgfVxuXG4gIGNvbnN0IHRtcFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgbGV0IGNlcnRIYXNoO1xuICB0cnkge1xuICAgIGNvbnN0IHRtcENlcnQgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgJ3NvdXJjZS5jZXInKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUodG1wQ2VydCwgY2VydCk7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctbm9vdXQnLCAnLWhhc2gnLCAnLWluJywgdG1wQ2VydF0pO1xuICAgIGNlcnRIYXNoID0gc3Rkb3V0LnRyaW0oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmV0cmlldmUgdGhlIGNlcnRpZmljYXRlIGhhc2guIGAgK1xuICAgICAgICAgICAgICAgICAgICBgSXMgdGhlIGNlcnRpZmljYXRlIHByb3Blcmx5IGVuY29kZWQgaW50byBiYXNlNjQtc3RyaW5nPyBgICtcbiAgICAgICAgICAgICAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgfVxuICBjb25zdCBkc3RQYXRoID0gcGF0aC5wb3NpeC5yZXNvbHZlKENFUlRTX1JPT1QsIGAke2NlcnRIYXNofS4wYCk7XG4gIGxvZy5kZWJ1ZyhgQ2hlY2tpbmcgaWYgdGhlIGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkIGF0ICcke2RzdFBhdGh9J2ApO1xuICByZXR1cm4gYXdhaXQgdGhpcy5maWxlRXhpc3RzKGRzdFBhdGgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3lzdGVtQ2FsbE1ldGhvZHM7XG5leHBvcnQgeyBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQgfTtcbiJdLCJmaWxlIjoibGliL3Rvb2xzL3N5c3RlbS1jYWxscy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
